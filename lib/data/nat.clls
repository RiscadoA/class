include "../traits/cloner.clls";;
include "../traits/dropper.clls";;
include "../traits/comparer.clls";;
include "string.clls";;
include "iter.clls";;
include "maybe.clls";;
include "bool.clls";;
include "gen.clls";;

type rec Nat {
    choice of {
        |#z: close
        |#s: Nat
    }
};;

// ---------------------------------- Traits ----------------------------------

proc rec clone_nat(nat: ~Nat, out: send Nat; Nat) {
    case nat of {
        |#z:
            wait nat;
            send out(n. #z n; close n);
            #z out; close out
        |#s:
            cut {
                clone_nat(nat, acc)
                |acc: recv ~Nat; ~Nat|
                recv acc(n);
                send out(m. #s m; fwd m n);
                #s out; fwd out acc
            }
    }
};;

proc rec cloner_nat(cloner: Cloner(Nat)) {
    case cloner of {
        |#close: close cloner
        |#clone:
            recv cloner(nat);
            cut {
                recv nat1(nat2);
                send cloner(nat1);
                send cloner(nat2);
                cloner_nat(cloner)
                |nat1: send Nat; Nat|
                clone_nat(nat, nat1)
            }
        |#fork:
            send cloner(c. cloner_nat(c));
            cloner_nat(cloner)
    }
};;

proc rec drop_nat(nat: ~Nat, out: close) {
    case nat of {
        |#z: fwd nat out
        |#s: drop_nat(nat, out)
    }
};;

proc rec dropper_nat(dropper: Dropper(Nat)) {
    case dropper of {
        |#close: close dropper
        |#drop:
            recv dropper(nat);
            cut {
                wait out;
                dropper_nat(dropper)
                |out: close|
                drop_nat(nat, out)
            }
        |#fork:
            send dropper(d. dropper_nat(d));
            dropper_nat(dropper)
    }
};;

proc rec compare_nat(x: ~Nat, y: ~Nat, out: Order) {
    case x of {
        |#z:
            wait x;
            case y of {
                |#z:
                    wait y;
                    #eq out; close out
                |#s:
                    #lt out;
                    cut {
                        wait drop_out;
                        close out
                        |drop_out: close|
                        drop_nat(y, drop_out)
                    }
            }
        |#s:
            case y of {
                |#z:
                    wait y;
                    #gt out;
                    cut {
                        wait drop_out;
                        close out
                        |drop_out: close|
                        drop_nat(x, drop_out)
                    }
                |#s:
                    compare_nat(x, y, out)
            }
    }
};;

proc rec comparer_nat(cmp: Comparer(Nat)) {
    case cmp of {
        |#close: close cmp
        |#compare:
            recv cmp(x);
            recv cmp(y);
            send cmp(out. compare_nat(x, y, out));
            comparer_nat(cmp)
    }
};;

// ------------------------------- Constructors -------------------------------

proc zero_nat(out: Nat) {
    #z out; close out
};;

proc one_nat(out: Nat) {
    #s out; zero_nat(out)
};;

proc two_nat(out: Nat) {
    #s out; one_nat(out)
};;

proc three_nat(out: Nat) {
    #s out; two_nat(out)
};;

proc four_nat(out: Nat) {
    #s out; three_nat(out)
};;

proc five_nat(out: Nat) {
    #s out; four_nat(out)
};;

proc six_nat(out: Nat) {
    #s out; five_nat(out)
};;

proc seven_nat(out: Nat) {
    #s out; six_nat(out)
};;

proc eight_nat(out: Nat) {
    #s out; seven_nat(out)
};;

proc nine_nat(out: Nat) {
    #s out; eight_nat(out)
};;

proc ten_nat(out: Nat) {
    #s out; nine_nat(out)
};;

// -------------------------------- Operators ---------------------------------

proc rec add_nat(x: ~Nat, y: ~Nat, out: Nat) {
    case x of {
        |#z: wait x; fwd y out
        |#s: #s out; add_nat(x, y, out)
    }
};;

proc rec sub_nat(x: ~Nat, y: ~Nat, out: Maybe(Nat)) {
    case y of {
        |#z: wait y; #some out; fwd x out
        |#s:
            case x of {
                |#z: wait x; #none out; drop_nat(y, out)
                |#s: sub_nat(x, y, out)
            }
    }
};;

proc rec mul_nat(x: ~Nat, y: ~Nat, out: Nat) {
    case x of {
        |#z:
            wait x;
            cut {
                drop_nat(y, drop_out)
                |drop_out: wait|
                wait drop_out;
                #z out; close out
            }
        |#s:
            cut {
                clone_nat(y, y2)
                |y2: recv ~Nat; ~Nat|
                recv y2(y1);
                cut {
                    mul_nat(x, y1, acc)
                    |acc: ~Nat|
                    add_nat(y2, acc, out)
                }
            }
    }
};;

proc mul_nat_10(x: ~Nat, out: Nat) {
    cut {
        ten_nat(ten)
        |ten: ~Nat|
        mul_nat(x, ten, out)
    }
};;

proc mul_nat_10_plus(x: ~Nat, y: ~Nat, out: Nat) {
    cut {
        mul_nat_10(x, mul)
        |mul: ~Nat|
        add_nat(y, mul, out)
    }
};;

proc rec div_nat_aux(gas: ~Nat, x: ~Nat, y: ~Nat, out: Maybe(send Nat; Nat)) {
    case gas of {
        |#z:
            wait gas;
            cut {
                drop_nat(x, drop_x)
                |drop_x: wait|
                wait drop_x;
                drop_nat(y, drop_y)
                |drop_y: wait|
                wait drop_y;
                #none out; close out
            }
        |#s:
            cut {
                clone_nat(y, y2)
                |y2: recv ~Nat; ~Nat|
                recv y2(y1);
                cut {
                    clone_nat(x, x2)
                    |x2: recv ~Nat; ~Nat|
                    recv x2(x1);
                    cut {
                        sub_nat(x1, y1, res)
                        |res: ~Maybe(Nat)|
                        case res of {
                            |#none:
                                cut {
                                    drop_nat(gas, drop_gas)
                                    |drop_gas: wait|
                                    wait drop_gas;
                                    wait res;
                                    #some out; send out(q. #z q; drop_nat(y2, q)); // Quotient = 0
                                    fwd x2 out // Remainder = x
                                }
                            |#some:
                                cut {
                                    drop_nat(x2, drop_done)
                                    |drop_done: wait|
                                    wait drop_done;
                                    div_nat_aux(gas, res, y2, rem)
                                    |rem: ~Maybe(send Nat; Nat)|
                                    case rem of {
                                        |#none: wait rem; #none out; close out
                                        |#some:
                                            recv rem(quot);
                                            #some out; send out(q. #s q; fwd quot q); // Quotient = 1 + recursion result
                                            fwd rem out // Remainder = recursion result
                                    }
                                }
                        }
                    }
                }
            }
    }
};;

// Outputs the quotient and remainder of the division of two natural numbers.
proc rec div_nat(x: ~Nat, y: ~Nat, out: Maybe(send Nat; Nat)) {
    cut {
        clone_nat(x, x2)
        |x2: recv ~Nat; ~Nat|
        recv x2(x1);
        cut {
            #s gas; fwd gas x2
            |gas: ~Nat|
            div_nat_aux(gas, x1, y, out)
        }
    }
};;

proc div_nat_10(x: ~Nat, out: send Nat; Nat) {
    cut {
        ten_nat(ten)
        |ten: ~Nat|
        div_nat(x, ten, res)
        |res: ~Maybe(send Nat; Nat)|
        case res of {
            |#none: wait res; send out(q. #z q; close q); #z out; close out
            |#some: fwd res out
        }
    }
};;

proc rec fold_add_nat(fold: IterFold(Nat, Nat)) {
    case fold of {
        |#close: close fold
        |#next:
            recv fold(nat);
            recv fold(acc);
            send fold(new_acc. add_nat(nat, acc, new_acc));
            fold_add_nat(fold)
    }
};;

proc rec map_inc_nat(map: IterMap(Nat, Nat)) {
    case map of {
        |#close: close map
        |#next:
            recv map(nat);
            send map(n. #s n; fwd n nat);
            map_inc_nat(map)
    }
};;

proc rec into_string_nat(nat: ~Nat, out: String) {
    case nat of {
        |#z: wait nat; #d0 out; #eof out; close out
        |#s: #s out; into_string_nat(nat, out)
    }
};;

proc rec map_into_string_nat(map: IterMap(Nat, String)) {
    case map of {
        |#close: close map
        |#next:
            recv map(nat);
            cut {
                into_string_nat(nat, str)
                |str: ~String|
                send map(str);
                map_into_string_nat(map)
            }
    }
};;

// Produces an iterator of all natural numbers less than the given natural natural.
proc rec iter_nat(nat: ~Nat, out: Iter(Nat)) {
    case nat of {
        |#z: wait nat; #close out; close out
        |#s:
            #next out; send out(m. #z m; close m);
            cut {
                iter_nat(nat, acc)
                |acc: ~Iter(Nat)|
                cut {
                    map_inc_nat(inc_nat)
                    |inc_nat: ~IterMap(Nat, Nat)|
                    map_iter<Nat, Nat>(acc, inc_nat, out)
                }
            }
    }
};;

// Produces a space separated string with a newline from an iterator of natural numbers.
proc into_string_iter_nat(ni: ~Iter(Nat), out: String) {
    cut {
        cut {
            map_into_string_nat(map)
            |map: ~IterMap(Nat, String)|
            map_iter<Nat, String>(ni, map, si)
        }
        |si: ~Iter(String)|
        intersperse_space_string_iter(si, s)
        |s: ~String|
        append_newline_string(s, out)
    }
};;

proc nat_gen(gen: Gen(Nat), nat: ~Nat) {
    cut {
        cloner_nat(cloner)
        |cloner: ~Cloner(Nat)|
        cloning_gen<Nat>(gen, cloner, nat, dropper)
        |dropper: recv ~Nat; close|
        recv dropper(n);
        drop_nat(n, dropper)
    }
};;

proc is_divisible_nat_pair(x: ~Nat, y: ~Nat, out: Bool) {
    cut {
        div_nat(x, y, rem)
        |rem: ~Maybe(send Nat; Nat)|
        case rem of {
            |#none: wait rem; #false out; close out
            |#some:
                recv rem(quot);
                case rem of {
                    |#z: wait rem; #true out; drop_nat(quot, out)
                    |#s:
                        cut {
                            drop_nat(quot, quot_done)
                            |quot_done: wait|
                            wait quot_done;
                            #false out;
                            drop_nat(rem, out)
                        }
                }
        }
    }
};;

proc rec is_divisible_nat_fold(fold: IterFold(Nat, Bool), natg: ~Gen(Nat)) {
    case fold of {
        |#close: #close natg; wait natg; close fold
        |#next:
            recv fold(divisor);
            recv fold(acc);
            case acc of {
                |#true:
                    wait acc;
                    send fold(b. true_bool(b));
                    cut {
                        drop_nat(divisor, drop_done)
                        |drop_done: wait|
                        wait drop_done;
                        is_divisible_nat_fold(fold, natg)
                    }
                |#false:
                    wait acc;
                    #next natg; recv natg(nat);
                    cut {
                        is_divisible_nat_pair(nat, divisor, is_divisible)
                        |is_divisible: ~Bool|
                        send fold(is_divisible);
                        is_divisible_nat_fold(fold, natg)
                    }
            }
    }
};;

proc skip_one_iter_nat(iter: ~Iter(Nat), out: Iter(Nat)) {
    case iter of {
        |#close: wait iter; #close out; close out
        |#next:
            recv iter(nat);
            cut {
                drop_nat(nat, drop_done)
                |drop_done: wait|
                wait drop_done;
                fwd iter out
            }
    }
};;

proc is_prime_nat(nat: ~Nat, out: Bool) {
    cut {
        nat_gen(natg, nat)
        |natg: ~Gen(Nat)|
        #next natg; recv natg(n);
        send pipe(larger_than_one. cut {
            iter_nat(n, all)
            |all: ~Iter(Nat)|
            skip_one_iter_nat(all, larger_than_zero)
            |larger_than_zero: ~Iter(Nat)|
            skip_one_iter_nat(larger_than_zero, larger_than_one)
        });
        send pipe(f. is_divisible_nat_fold(f, natg));
        send pipe(b. false_bool(b));
        close pipe
        |pipe: recv ~Iter(Nat); recv ~IterFold(Nat, Bool); recv ~Bool; wait|
        recv pipe(ns);
        recv pipe(fold);
        recv pipe(base);
        wait pipe;
        fold_iter<Nat, Bool>(ns, fold, base, is_divisible)
        |is_divisible: ~Bool|
        not_bool(is_divisible, out)
    }
};;

proc rec iter_primes_nat_aux(nats: ~Iter(Nat), out: Iter(Nat)) {
    case nats of {
        |#close: wait nats; #close out; close out
        |#next:
            recv nats(nat);
            cut {
                clone_nat(nat, nat1)
                |nat1: recv ~Nat; ~Nat|
                recv nat1(nat2);
                send pipe(b. is_prime_nat(nat1, b));
                send pipe(nat2);
                close pipe
                |pipe: recv ~Bool; recv ~Nat; wait|
                recv pipe(is_prime);
                recv pipe(nat);
                wait pipe;
                case is_prime of {
                    |#true:
                        wait is_prime;
                        #next out; send out(nat);
                        iter_primes_nat_aux(nats, out)
                    |#false:
                        wait is_prime;
                        cut {
                            drop_nat(nat, drop_done)
                            |drop_done: wait|
                            wait drop_done;
                            iter_primes_nat_aux(nats, out)
                        }
                }
            }
    }
};;

// Generates an iterator over all prime numbers less than the given natural number.
proc iter_primes_nat(nat: ~Nat, out: Iter(Nat)) {
    cut {
        iter_nat(nat, all)
        |all: ~Iter(Nat)|
        skip_one_iter_nat(all, larger_than_zero)
        |larger_than_zero: ~Iter(Nat)|
        skip_one_iter_nat(larger_than_zero, larger_than_one)
        |larger_than_one: ~Iter(Nat)|
        iter_primes_nat_aux(larger_than_one, out)
    }
};;

// --------------------------------- Examples ---------------------------------

proc test_iter_nat() {
    cut {
        #s n; #s n; #s n; zero_nat(n)
        |n: ~Nat|
        iter_nat(n, ni)
        |ni: ~Iter(Nat)|
        into_string_iter_nat(ni, s)
        |s: ~String|
        print_string_end(s)
    }
};;

proc test_div_nat() {
    cut {
        send xy(x. #s x; #s x; #s x; #s x; #s x; zero_nat(x));
        send xy(y. #s y; #s y; zero_nat(y));
        close xy
        |xy: recv ~Nat; recv ~Nat; wait|
        recv xy(x);
        recv xy(y);
        wait xy;
        div_nat(x, y, rem)
        |rem: ~Maybe(send Nat; Nat)|
        case rem of {
            |#none: wait rem; println("Division by zero"); ()
            |#some:
                recv rem(quot);
                cut {
                    #next strs; send strs(s. #q s; #sp s; empty_string(s));
                    #next strs; send strs(s. into_string_nat(quot, s));
                    #next strs; send strs(s. #nl s; #r s; #sp s; empty_string(s));
                    #next strs; send strs(s. into_string_nat(rem, s));
                    #next strs; send strs(s. #nl s; empty_string(s));
                    #close strs; close strs
                    |strs: ~Iter(String)|
                    join_string_iter(strs, str)
                    |str: ~String|
                    print_string_end(str)
                }
        }
    }
};;

proc test_is_prime_nat() {
    cut {
        // 11 is prime
        #s nat; #s nat; #s nat; #s nat; #s nat; #s nat; #s nat; #s nat; #s nat; #s nat; #s nat; zero_nat(nat)
        |nat: ~Nat|
        is_prime_nat(nat, is_prime)
        |is_prime: ~Bool|
        case is_prime of {
            |#true: wait is_prime; println("Prime"); ()
            |#false: wait is_prime; println("Not prime"); ()
        }
    }
};;
