include "../traits/cloner.clls";;
include "../traits/dropper.clls";;
include "../traits/comparer.clls";;
include "string.clls";;
include "iter.clls";;
include "maybe.clls";;

type rec Nat {
    choice of {
        |#z: close
        |#s: Nat
    }
};;

// ---------------------------------- Traits ----------------------------------

proc rec clone_nat(nat: ~Nat, out: send Nat; Nat) {
    case nat of {
        |#z:
            wait nat;
            send out(n. #z n; close n);
            #z out; close out
        |#s:
            cut {
                clone_nat(nat, acc)
                |acc: recv ~Nat; ~Nat|
                recv acc(n);
                send out(m. #s m; fwd m n);
                #s out; fwd out acc
            }
    }
};;

proc rec cloner_nat(cloner: Cloner(Nat)) {
    case cloner of {
        |#close: close cloner
        |#clone:
            recv cloner(nat);
            cut {
                recv nat1(nat2);
                send cloner(nat1);
                send cloner(nat2);
                cloner_nat(cloner)
                |nat1: send Nat; Nat|
                clone_nat(nat, nat1)
            }
        |#fork:
            send cloner(c. cloner_nat(c));
            cloner_nat(cloner)
    }
};;

proc rec drop_nat(nat: ~Nat, out: close) {
    case nat of {
        |#z: fwd nat out
        |#s: drop_nat(nat, out)
    }
};;

proc rec dropper_nat(dropper: Dropper(Nat)) {
    case dropper of {
        |#close: close dropper
        |#drop:
            recv dropper(nat);
            cut {
                wait out;
                dropper_nat(dropper)
                |out: close|
                drop_nat(nat, out)
            }
        |#fork:
            send dropper(d. dropper_nat(d));
            dropper_nat(dropper)
    }
};;

proc rec compare_nat(x: ~Nat, y: ~Nat, out: Order) {
    case x of {
        |#z:
            wait x;
            case y of {
                |#z:
                    wait y;
                    #eq out; close out
                |#s:
                    #lt out;
                    cut {
                        wait drop_out;
                        close out
                        |drop_out: close|
                        drop_nat(y, drop_out)
                    }
            }
        |#s:
            case y of {
                |#z:
                    wait y;
                    #gt out;
                    cut {
                        wait drop_out;
                        close out
                        |drop_out: close|
                        drop_nat(x, drop_out)
                    }
                |#s:
                    compare_nat(x, y, out)
            }
    }
};;

proc rec comparer_nat(cmp: Comparer(Nat)) {
    case cmp of {
        |#close: close cmp
        |#compare:
            recv cmp(x);
            recv cmp(y);
            send cmp(out. compare_nat(x, y, out));
            comparer_nat(cmp)
    }
};;

// ------------------------------- Constructors -------------------------------

proc zero_nat(out: Nat) {
    #z out; close out
};;

// -------------------------------- Operators ---------------------------------

proc rec add_nat(x: ~Nat, y: ~Nat, out: Nat) {
    case x of {
        |#z: wait x; fwd y out
        |#s: #s out; add_nat(x, y, out)
    }
};;

proc rec sub_nat(x: ~Nat, y: ~Nat, out: Maybe(Nat)) {
    case y of {
        |#z: wait y; #some out; fwd x out
        |#s:
            case x of {
                |#z: wait x; #none out; drop_nat(y, out)
                |#s: sub_nat(x, y, out)
            }
    }
};;

proc rec mul_nat(x: ~Nat, y: ~Nat, out: Nat) {
    case x of {
        |#z:
            wait x;
            cut {
                drop_nat(y, drop_out)
                |drop_out: wait|
                wait drop_out;
                #z out; close out
            }
        |#s:
            cut {
                clone_nat(y, y2)
                |y2: recv ~Nat; ~Nat|
                recv y2(y1);
                cut {
                    mul_nat(x, y1, acc)
                    |acc: ~Nat|
                    add_nat(y2, acc, out)
                }
            }
    }
};;

proc rec div_nat_aux(gas: ~Nat, x: ~Nat, y: ~Nat, out: Maybe(send Nat; Nat)) {
    case gas of {
        |#z:
            wait gas;
            cut {
                drop_nat(x, drop_x)
                |drop_x: wait|
                wait drop_x;
                drop_nat(y, drop_y)
                |drop_y: wait|
                wait drop_y;
                #none out; close out
            }
        |#s:
            cut {
                clone_nat(y, y2)
                |y2: recv ~Nat; ~Nat|
                recv y2(y1);
                cut {
                    clone_nat(x, x2)
                    |x2: recv ~Nat; ~Nat|
                    recv x2(x1);
                    cut {
                        sub_nat(x1, y1, res)
                        |res: ~Maybe(Nat)|
                        case res of {
                            |#none:
                                cut {
                                    drop_nat(gas, drop_gas)
                                    |drop_gas: wait|
                                    wait drop_gas;
                                    wait res;
                                    #some out; send out(q. #z q; drop_nat(y2, q)); // Quotient = 0
                                    fwd x2 out // Remainder = x
                                }
                            |#some:
                                cut {
                                    drop_nat(x2, drop_done)
                                    |drop_done: wait|
                                    wait drop_done;
                                    div_nat_aux(gas, res, y2, rem)
                                    |rem: ~Maybe(send Nat; Nat)|
                                    case rem of {
                                        |#none: wait rem; #none out; close out
                                        |#some:
                                            recv rem(quot);
                                            #some out; send out(q. #s q; fwd quot q); // Quotient = 1 + recursion result
                                            fwd rem out // Remainder = recursion result
                                    }
                                }
                        }
                    }
                }
            }
    }
};;

// Outputs the quotient and remainder of the division of two natural numbers.
proc rec div_nat(x: ~Nat, y: ~Nat, out: Maybe(send Nat; Nat)) {
    cut {
        clone_nat(x, x2)
        |x2: recv ~Nat; ~Nat|
        recv x2(x1);
        cut {
            #s gas; fwd gas x2
            |gas: ~Nat|
            div_nat_aux(gas, x1, y, out)
        }
    }
};;

proc rec fold_add_nat(fold: IterFold(Nat, Nat)) {
    case fold of {
        |#close: close fold
        |#next:
            recv fold(nat);
            recv fold(acc);
            send fold(new_acc. add_nat(nat, acc, new_acc));
            fold_add_nat(fold)
    }
};;

proc rec map_inc_nat(map: IterMap(Nat, Nat)) {
    case map of {
        |#close: close map
        |#next:
            recv map(nat);
            send map(n. #s n; fwd n nat);
            map_inc_nat(map)
    }
};;

proc rec into_string_nat(nat: ~Nat, out: String) {
    case nat of {
        |#z: wait nat; #d0 out; #eof out; close out
        |#s: #s out; into_string_nat(nat, out)
    }
};;

proc rec map_into_string_nat(map: IterMap(Nat, String)) {
    case map of {
        |#close: close map
        |#next:
            recv map(nat);
            cut {
                into_string_nat(nat, str)
                |str: ~String|
                send map(str);
                map_into_string_nat(map)
            }
    }
};;

// Produces an iterator of all natural numbers less than the given natural natural.
proc rec iter_nat(nat: ~Nat, out: Iter(Nat)) {
    case nat of {
        |#z: wait nat; #close out; close out
        |#s:
            #next out; send out(m. #z m; close m);
            cut {
                iter_nat(nat, acc)
                |acc: ~Iter(Nat)|
                cut {
                    map_inc_nat(inc_nat)
                    |inc_nat: ~IterMap(Nat, Nat)|
                    map_iter<Nat, Nat>(acc, inc_nat, out)
                }
            }
    }
};;

// Produces a space separated string with a newline from an iterator of natural numbers.
proc into_string_iter_nat(ni: ~Iter(Nat), out: String) {
    cut {
        cut {
            map_into_string_nat(map)
            |map: ~IterMap(Nat, String)|
            map_iter<Nat, String>(ni, map, si)
        }
        |si: ~Iter(String)|
        cut {
            cut {
                #sp sep; empty_string(sep)
                |sep: ~String|
                string_gen(gen, sep)
            }
            |gen: ~Gen(String)|
            intersperse_iter<String>(si, gen, si2)
        }
        |si2: ~Iter(String)|
        cut {
            fold_join_string(fold)
            |fold: ~IterFold(String, String)|
            cut {
                empty_string(acc)
                |acc: ~String|
                fold_iter<String, String>(si2, fold, acc, s)
            }
        }
        |s: ~String|
        cut {
            #nl nl; empty_string(nl)
            |nl: ~String|
            join_string(s, nl, out)
        }
    }
};;

// --------------------------------- Examples ---------------------------------

proc test_iter_nat() {
    cut {
        #s n; #s n; #s n; zero_nat(n)
        |n: ~Nat|
        iter_nat(n, ni)
        |ni: ~Iter(Nat)|
        into_string_iter_nat(ni, s)
        |s: ~String|
        print_string_end(s)
    }
};;

proc test_div_nat() {
    cut {
        send xy(x. #s x; #s x; #s x; #s x; #s x; zero_nat(x));
        send xy(y. #s y; #s y; zero_nat(y));
        close xy
        |xy: recv ~Nat; recv ~Nat; wait|
        recv xy(x);
        recv xy(y);
        wait xy;
        div_nat(x, y, rem)
        |rem: ~Maybe(send Nat; Nat)|
        case rem of {
            |#none: wait rem; println("Division by zero"); ()
            |#some:
                recv rem(quot);
                cut {
                    #next strs; send strs(s. #q s; #sp s; empty_string(s));
                    #next strs; send strs(s. into_string_nat(quot, s));
                    #next strs; send strs(s. #nl s; #r s; #sp s; empty_string(s));
                    #next strs; send strs(s. into_string_nat(rem, s));
                    #next strs; send strs(s. #nl s; empty_string(s));
                    #close strs; close strs
                    |strs: ~Iter(String)|
                    join_string_iter(strs, str)
                    |str: ~String|
                    print_string_end(str)
                }
        }
    }
};;
