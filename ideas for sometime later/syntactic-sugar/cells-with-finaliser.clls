type corec Init(A){
    offer of {
        |#init; recv coaffine ~A; recv coaffine A; Full(A)
    }
} and Full(A){
    offer of {
        |#take; send {affine A};Empty(A)
        |#share; recv Full(A); Full(A)
        |#release 
    }
}    and Empty(A) { //we can also have options to share, but right now we opt not for simplicity
        offer of {
            |#put: recv coaffine ~A; Full(A)
    }
};;

type rec SS(A){
state Rep(A)
} and Rep(A){
    send Int; //number of processes sharing the cell
    send affine A; //stored value
    send Finaliser // finaliser
} and Finaliser(A){
    recv coaffine ~A 
};;


proc rec mtake<A>(x:Full(A), c:usage ~Rep(A),dum:?coaffine ~A){
    case x of {
        |#release;
        n v fi := c; 
        if(n == 1){
            f <- vi; 
            c := 0 dum (n=<-)
        }{
            c := n-1 v fi  
        }

        |#share;
        y=<-x; 
        n v fi := c; 
        c := n+1 v fi; 
        fork c <- mtake<A>(y,c,dum);
        mtake<A>(x,c,dum)
        }

        |#take;
        n v fi := c;
        x <- v; 
        mput<A>(x,n,fi,dum)
    }
} and mput<A>(x:Empty(A), fi:coaffine A, c:usagel ~Rep(A), n:~Int dum:?coaffine ~A){
    case x of {
        |#put;
        v <- x; 
        c := n v fi; 
        mtake<A>(x,c,dum)
    }
};;

proc minit<A>(x:Init(A),dum:?coaffine ~A){
    case x of {
        |#init;
        ini fi =<- x; 
        fork c <- new c := 1 ini fi;
        mtake<A>(x,c,dum) 
    }
};;



proc test0(){
    cut{
        !dum(dum0);
        affine dum0;
        send dum0(n. affine n;
                    let n 0);
        affine dum0;
        println("dum0 = " + dum0);
        ()
        |dum:?coaffine{recv coaffine colint; coaffine lint}|
        minit<lint>(x;dum)
        |x:~Init(lint)|
        #init x;
        send x(ini. affine ini;
                    let ini 0);
        send x(fi.  affine fi;
                    println("Final value is " + fi);
                    ());
        #release x;
        close x
    }
};;

proc test1(){
    func dum <- 0; 
    x <- #init 0 (fi. v <- fi; println("Final value is " + fi)); 
    x <- #take;
    n =<- x; 
    x <- #put n+2;
    x <- #release
};;

proc test2(){
    func dum <- 0; 
    x <- #init 0 (fi. v <- fi; println("Final value is " + fi)); 
    x <- #take; 
    n =<- x; 
    x <- #put n-2; 
    x <- #take; 
    n =<- x; 
    x <- #put 2*n; 
    x <- #release 
};;

proc test3(){
    func dum <- 0; 
    x <- #init 0 (fi. v <- fi; println("Final value is " + fi)); 
    x <- #share (y. sleep 10; 
                    y <- #take; 
                    n =<- y; 
                    y <- #put 2*n #release); 
    x <- #share (y. sleep 20;
                    z <- #take;
                    n =<- z;
                    z <- #put n-1 #release);
    x <- #take;
    n =<- x; 
    x <- #put n+2 #release 
};;