type rec Nat {
    choice of {
        |#Z: close
        |#S: Nat
    }
};;

proc zero(n:Nat) {
    #Z n;
    close n
};;

proc rec printNat(n:~Nat) {
    case n of {
        |#Z: println("Z"); wait n; ()
        |#S: print("S "); printNat(n)
    }
};;

proc rec add(n:~Nat,m:~Nat,r:Nat) {
    case n of {
        |#Z: wait n; fwd m r
        |#S: #S r; add(n,m,r)
	}
};;

/** explicitly "brute force" contraction (copy) and weakening (drop) **/
/** possible for inductive types **/

proc rec drop(n:~Nat) {
    case n of {
        |#Z: wait n; ()
        |#S: drop(n)
	}
};;


proc rec copy(n:~Nat, d:send Nat;Nat) {
    case n of {
        |#Z: wait n; send d (z.zero(z)); zero(d)
        |#S: cut {
		copy(n,d0)
		| d0: ~send Nat; Nat|
		recv d0(c0);
		send d (s.#S s; fwd c0 s);
		#S d; fwd d0 d
            }
	}
};;

proc unsafe_rec mul(n:~Nat,m:~Nat,r:Nat) {
    case n of {
        |#Z: wait n; #Z r; par { drop (m) || close r }
        |#S: cut {
		copy(m,d0)
		| d0:~send Nat;Nat|
		recv d0(m0);
		cut {
			mul(n,m0,r0)
			| r0: ~Nat|
			add(d0,r0,r)
		    }
	     }
     } 
};;

proc main1() {
    cut {
        #S n; #S n; zero(n)
        |n:~Nat|
        printNat(n)
    }
};;

proc main2() {
    cut {
        #S n; #S n;  #S n; #S n; zero(n)
        |n:~Nat|
        copy(n,d0)
        |d0:~send Nat;Nat|
	recv d0(n0);
	par { printNat(n0) || printNat(d0) }
    }
};;

proc main3() {
    cut {
        #S n; #S n; #S n; zero(n)
        |n:~Nat|
        #S m; #S m; #S m; zero(m)
        |m:~Nat|
        mul(n,m,r)
        |r:~Nat|
        printNat(r)
    }
};;

proc main() {
    par {
        println("main1:"); main1()
        ||
        println("main2:"); main2()
        ||
        println("main3:"); main3()
    }
};;
