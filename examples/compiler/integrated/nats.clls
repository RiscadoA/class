type rec Nat{
    choice of {
        |#Z: close      
        |#S: Nat        
    }
};;

proc zero(n:Nat){ #Z n; close n };;

proc one(n:Nat){ #S n; #Z n; close n };;

proc two(n:Nat){#S n; #S n; #Z n; close n};;

proc succ(n:~Nat, m:Nat){ #S m; fwd n m};;

proc three(m:Nat){
    cut{
        two(n)
        |n:~Nat|
        succ(n,m)
    }
};;

proc rec dispose(n:~Nat, x:close) {
    case n of {
        |#Z: wait n; close x
        |#S: cut{ dispose(n, y) |y:wait| wait y; close x}
    }
};;

proc rec double(n:~Nat, m:Nat)
{
    case n of {
        |#Z: wait n; zero(m)
        |#S: cut{
                double(n,k)             
                |k:~Nat|
                #S m; #S m; fwd m k
                }
    }
};;

proc rec add(n:~Nat, m:~Nat, r:Nat)
{
   case n of {
    |#Z: wait n;
         fwd m r
    |#S: #S r;
         add(n,m,r)
   }
};;

proc rec mul(n:~Nat, m:?~Nat, r:Nat)
{
   case n of {
   |#Z: ?m;wait n; #Z r; close r
   |#S: ?m;
	cut {
	!m1(v:Nat);call m(m1:~Nat);fwd m1 v
	|m1:?~Nat|
   	mul(n,m1,r0)
	|r0:~Nat|
 	call m(m2:~Nat);
	add(m2,r0,r)
	}
   } 
};;

proc rec nat2lint(n:~Nat, m:lint){
    case n of {
        |#Z: wait n; let m 0
        |#S: cut{ nat2lint(n, k) |k:colint| let m k+1}
    }
};;


// next proc crashes compiler 1-1-2025 (LC)

proc unsafe_rec lint2nat(m:Nat;n:colint) {
    if(n==0 or n <0){
        zero(m)
    }{
       cut{
        lint2nat(x;n-1)
        |x:~Nat|
        #S m; fwd m x
    }
    }
};;

/*

proc embedd(n:~Nat, m:lint){
    nat2lint(n,m)
};;

proc pred(n:~Nat, m:Nat){
    case n of {
        |#Z: wait n; zero(m)
        |#S: fwd n m
    }
};;

proc predB(m:!Nat;n:~Nat){
    !m(m0:Nat);
    call n(n0:~Nat);
    pred(n0,m0)
};;


*/

proc rec toStr(n:~Nat, s: lstring){
    case n of {
        |#Z: wait n; let s "Z"
        |#S: cut{
                toStr(n,x)
                |x:~lstring|
                let s "S "+x
                }
    }
};;


proc main(){
cut{
    three(n)
    |n:~Nat|
    toStr(n,s)
    |s:~lstring|
    println(s);
    ()
}
};;

/*
proc main1(){
cut{
    three(n)
    |n:~Nat|
    double(n,m)
    |m:~Nat|
    toStr(m,s)
    |s:~lstring|
    println(s);
    ()
}
};;

proc main2(){
cut{
    three(n)
    |n:~Nat|
    println("Disposing 3...");
    dispose(n,x)
    |x:wait|
    wait x;
    println("... end.");
    ()
}
};;

proc main(){
cut{
    !n3(v:Nat);three(v)
    |n3:?~Nat|
    three(m)
    |m:~Nat|
    mul(m,n3,r)
    |r:~Nat|
    embedd(r,k)
    |k:colint|
    println("3*3 = " + k);
    ()
}
};;

/*

proc test4a(){
        cut{
            one(n)
            |n:~Nat|
            even(n,b)
            |b:~lbool|
            println("is 3 even? " + b);
            ()
        } 
};;

proc testpar(){
par{
        cut{
            zero(n)
            |n:~Nat|
            even(n,b)
            |b:~lbool|
            println("is 0 even? " + b);
            ()
        }
        ||
        cut{
            zero(n)
            |n:~Nat|
            odd(n,b)
            |b:~lbool|
            println("is 0 odd? " + b);
            ()
        }
      || 
	println("3 mix even");
        cut{
            three(n)
            |n:~Nat|
            even(n,b)
            |b:~lbool|
            println("is 3 even? " + b);
            ()
        } 
        ||
	println("3 mix odd");
        cut{
            three(n)
            |n:~Nat|
            odd(n,b)
            |b:~lbool|
            println("is 3 odd? " + b);
            ()
        }
	
}
};;

*/