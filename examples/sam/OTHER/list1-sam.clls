
type rec List {
    choice of {
        |#Nil:  close
        |#Cons: List // same issue as in ackerman ....
    }
};;

proc nil(l:List){
    #Nil l; close l
};;

proc cons(l:~List, nl:List){
       #Cons nl;  fwd l nl
};;


proc rec printlist(l:~List){
    case l of {
        |#Nil: wait l; println ("NIL"); ()
        |#Cons: println ("ELT"); printlist(l)
    }
};;

proc t1()
{
cut {
    nil(l0)
    | l0:~List|
    printlist(l0)
    }
};;


proc t2() {
cut {
    #Nil l0; close l0
    | l0:~List|
    #Cons l1; fwd l1 l0
    | l1:~List|
    #Cons l2; fwd l2 l1
    | l2:~List|
    printlist(l2)
    }
};;

proc t3() 
{
cut {
    #Nil l0; close l0
    | l0:~List|
    cons(l0,l1)
    | l1:~List|
    cons(l1,l2)
    | l2:~List|
    printlist(l2)
}
};;

proc t3a() 
{
cut {
    #Nil l0; close l0
    | l0:~List|
    #Cons l1; fwd l1 l0
    | l1:~List|
    #Cons l2; fwd l2  l1
    | l2:~List|
    printlist(l2)
}
};;


proc t4() {
cut {
    nil(l0)
    | l0:~List|
    cons(l0,l1)
    | l1:~List|
    cons(l1,l2)
    | l2:~List|
    cons(l2,l3)
    | l3:~List|
    cons(l3,l4)
    | l4:~List|
    printlist(l4)
    }
};;

sam t2();;

/*

sam t1();;
sam t2();;
sam t3();;
sam t4();;

*/
