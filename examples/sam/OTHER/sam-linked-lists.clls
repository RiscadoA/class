
type rec SList(A){
    state {
        List(A)
    }
} and List(A) { // unfold here ... inference!
    choice of {
        |#Null: close
        |#Next: send {affine A}; SList(A)
    }
};;

proc single<A>(a:coaffine ~A, n:affine List(A)) {
    affine n;
    unfold n;
    #Next n;
    send n(a);
    cell n(x. affine x; #Null x; close x)
};;

proc nil<A>(l: affine List (A)){
    affine l;
     unfold l;
    #Null l;
    close l
};;

proc cnext<A>(a:coaffine ~A, c:~SList(A), ln: affine List(A) ){
   affine ln;
   unfold ln;
   #Next ln;
   send ln(a);
   fwd ln c
};;

proc rec append<A>(c1:~SList(A), l2:~ affine List(A), c2:SList(A)) {
   take c1(l);
 //  use l;
  //  unfold l;
   case l of {
        |#Null: wait l;
                put c1(l2);
                unfold c2; // necessary to infer
                fwd c1 c2

        |#Next: recv l(a);
                cut{
                    append<A>(l,l2,x)
                    |x:~SList(A)|
                    put c1(y. cnext<A>(a,x,y));
                   // unfold c2;
                   fwd c1 c2
                }
    }
};;


proc insertatHead<A>(a:coaffine ~A,l:~SList(A), nl: SList(A)){
    take l(n);
    cut{
        cell ll(n)
        |ll:~SList(A)|
        put l(nn. cnext<A>(a,ll,nn));
 	unfold nl; 
        fwd l nl
    }
};;

proc rec insertatTail<A>(l:~SList(A),a:coaffine ~A, nl: SList(A)){
   cut{
        single<A>(a,n)
        |n:coaffine ~List(A)|
        append<A>(l, n, nl)
    }
};;


proc rec printSListInt(lp:~SList(!lint), nl:SList(!lint)){
    unfold lp;
    take lp(n);
    use n;
    unfold n;
    case n of {
        |#Null: wait n;
                put lp(v. nil<!lint>(v));
                println("__END__");
 	       unfold nl; // not infer ??
               fwd lp nl
        |#Next: recv n(k:coaffine ?colint);
                print(k + " ");
                cut{
                    printSListInt(n, x)
                    |x:~SList(!lint)|
                    put lp(nn. cnext<!lint>(k,x,nn));
		    unfold nl; // not infer ??
                    fwd lp nl
                }
    }
};;


proc unsafe_rec SListNto1(l:SList(!lint);a:colint){
    if(a == 0){
        cell l(x. nil<!lint>(x))
    }
    {
        cut{
            SListNto1(x;a-1)
            |x:~SList(!lint)|
	    cell l(y. cnext<!lint>(a,x,y))
        }
    }
};;

//auxiliary process for defining insertionSort
proc rec insert(l:~SList(!lint), nn: affine List(!lint); a:colint){
    unfold l;
    take l(n);
    use n;
    unfold n;
    case n of {
        |#Null: wait n;
                put l(x. nil<!lint>(x));
                cnext<!lint>(a,l,nn)

        |#Next: recv n(b);
                if(a < b)
                {
                    put l(x.  cnext<!lint>(b,n,x));
                    cnext<!lint>(a,l,nn)

                }
                {
                    put l(x. insert(n,x;a));
                    cnext<!lint>(b,l,nn)
                }
    }
};;


proc rec insertionSort(l:~SList(!lint), nl:SList(!lint)){
   // unfold l;
    take l(n);
    use n;
    unfold n;
    case n of {
        |#Null: wait n;
                put l(n. nil<!lint>(n));
 	        unfold nl; // not infer ??
               fwd l nl

        |#Next:
	       recv n(a:coaffine ?colint);
                cut{
                    insertionSort(n,x)
                    |x:~SList(!lint)|
                    put l(nn. insert(x,nn;a));
		    unfold nl; // not infer ??
                    fwd l nl
                }
    }
};;

proc testl(nl: affine List(!lint); k:~lint) {
    cut{
        SListNto1(l0;k)
         |l0:~SList(!lint)|
	unfold l0;
	take l0(n);
	put l0(x. nil<!lint>(x));
	par {
	fwd n nl
	||
	release l0
        }
   }
};;

//         testl(l1;2) crashes if spurious arg "2"

proc testapp(){
    cut{
        SListNto1(l0;10)
        |l0:~SList(!lint)|
        testl(l1;10)
        |l1:~ affine List(!lint) |
	append<!lint>(l0, l1, l2)
        |l2:~SList(!lint)|
        printSListInt(l2,l3)
        |l3:~SList(!lint)|
        release l3
    }
};;


proc test00(){
    cut{
	unfold l2;
	cell l2(x. affine x; unfold x; #Null x; close x)
        |l2:~SList(!lint)|
        printSListInt(l2,l3)
        |l3:~SList(!lint)|
        release l3
    }
};;


proc test0(){
    cut{
        SListNto1(l0;1)
        |l0:~SList(!lint)|
        printSListInt(l0,l1)
        |l1:~SList(!lint)|
        insertionSort(l1, l2)
        |l2:~SList(!lint)|
        printSListInt(l2,l3)
        |l3:~SList(!lint)|
        release l3
    }
};;

proc test01(){
    cut{
        SListNto1(l0;1)
        |l0:~SList(!lint)|
        printSListInt(l0,l1)
        |l1:~SList(!lint)|
        release l1
    }
};;


proc test11(){
    cut{
        SListNto1(l0;1)
        |l0:~SList(!lint)|
        insertatTail<!lint>(l0,5,l1)
        |l1:~SList(!lint)|
	release l1
    }
};;


proc test1(){
    cut{
        SListNto1(l0;10)
        |l0:~SList(!lint)|
        insertatTail<!lint>(l0,42,l1)
        |l1:~SList(!lint)|
        printSListInt(l1, l2)
        |l2:~SList(!lint)|
	release l2
    }
};;

proc test2(){
    cut{
        SListNto1(l0;100)
        |l0:~SList(!lint)|
        printSListInt(l0, l2)
        |l2:~SList(!lint)|
        release l2
    }
};;


proc test4(){
    cut{
        SListNto1(l0;1)
        |l0:~SList(!lint)|
	release l0
    }
};;


/*
    Concurrent sorted linked list
*/

/*
proc contains(l:~SList(!lint), x:send SList(!lint);send lbool; close; k:colint){
    take l(n:coaffine ~List(!lint));
    use n;
    case n of {
        |#Null: wait n;
                put l(nn: affine nn.
                          nil<!lint>(nn));
                send x (nl:SList(!lint). fwd nl l);
                send x(b:lbool. let b false);
                close x

        |#Next: recv n(a:coaffine ?colint);
                use a;
                ?a;
                if(a < k)
                {
                    cut{
                        recv y(nl:~SList(!lint));
                        put l(nn:   affine List(!lint).
                                    cnext<!lint>(
                        recv
                        contains(n, y;k)
                    }
                }
                {
                    put l(nn:   affine List(!lint).
                                cnext<!lint>(a, n;nn));
                    send x(ld:SList(!lint). fwd ld l);
                    if(k < a)
                    {
                     send x(b:lbool. let b false);
                     close x
                    }
                    {// a == k
                        send x(b:lbool. let b true);
                        close x
                    }
                }


                cut{
                    recv y(
                    |y:send SList(!lint); send lbool; close|
                    contains(n, y;k)
                }

    }
};;
*/
