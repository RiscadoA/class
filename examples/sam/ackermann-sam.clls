/*
    Implements the Ackermann function with Church Numerals
    (https://en.wikipedia.org/wiki/Ackermann_function),
    more specifically its definition as an iterated 1-ary function:
    A_0(n)     = n+1
    A_{m+1}(n) = A_m^{n+1}(1)
*/


include "toy-rec.clls";;

proc id<X>(f:recv ~X; send X; close){
    recv f(x);
    send f(x);
    close f
};;

proc idx(f:recv ~Nat; send Nat; close){
    recv f(x);
    send f(x);
    close f
};;

proc rec iter_(n:~Nat, g:recv ~Nat; send Nat; close ; f: ~ recv ~Nat; send Nat; close){
    case n of {
        |#Z: wait n;idx(g)
        |#S: cut{
                iter_(n,h; f)
                |h:send Nat;recv ~Nat; wait|
                recv g(x);
                send h(x);
                call f(f0);
		recv h(hx);
                send f0(hx);
		recv f0(hy);
		send g(hy);
		wait f0;
		wait h;
		close g
        }
    }
};;


/*
A_0(n) = n +1
A_{m+1}(n)  = A_m^{n+1}(1)
*/

proc rec ackerAux(m:~Nat, f:!recv ~Nat; send Nat; close){
    case m of {
        |#Z:    wait m;
                !f(f0);
                recv f0(n);
		send f0(f0a. 
                #S f0a;
                fwd f0a n);
		close f0

        |#S:    cut {
                    ackerAux(m,g)
                    |g:?send Nat; recv ~Nat; wait|
                    !f(f0);
                    recv f0(n);
                    cut{
                        #S k; fwd k n
                        |k:~Nat|
                        iter_(k,h;g)
                        |h:send Nat;recv ~Nat; wait|
                        send h(x.one(x));
			recv h(xn);
			send f0(xn);
			wait h;
			close f0
			}
                 }
        }
};;

proc acker(m:~Nat, n:~Nat, r:Nat){
    cut{
        ackerAux(m,f)
        |f:?send Nat;recv ~Nat; wait|
        call f(f0b);
        send f0b(n);
	recv f0b(r0);
	wait f0b;
        fwd r0 r
    }
};;


proc main() {
  cut {
     six(n)
     |n:~Nat|
     three(m)
     |m:~Nat|
     acker(m,n,r)
     |r:~Nat|
     printNat(r)
     }
};;

proc test1() { // crash
  cut {
     three(n)
     |n:~Nat|
     three(m)
     |m:~Nat|
     acker(m,n,r)
     |r:~Nat|
     printNat(r)
     }
};;


sam test0();;


proc computep() {
  cpar {
     cut {
     	  six(n0)
     	  |n0:~Nat|
     	  three(m0)
     	  |m0:~Nat|
     	  acker(m0,n0,r0)
     	  |r0:~Nat|
     	  printNat(r0)
         }
	 ||
    cut {
     	  six(n1)
     	  |n1:~Nat|
     	  three(m1)
     	  |m1:~Nat|
     	  acker(m1,n1,r1)
     	  |r1:~Nat|
     	  printNat(r1)
         }
	 }
};;

proc computes() {
  par {
     cut {
     	  six(n0)
     	  |n0:~Nat|
     	  three(m0)
     	  |m0:~Nat|
     	  acker(m0,n0,r0)
     	  |r0:~Nat|
     	  printNat(r0)
         }
	 ||
    cut {
     	  six(n1)
     	  |n1:~Nat|
     	  three(m1)
     	  |m1:~Nat|
     	  acker(m1,n1,r1)
     	  |r1:~Nat|
     	  printNat(r1)
         }
	 }
};;

