type corec 
ICounter(N,NZ) {
	affine
	LCounter(N,NZ)
}
and
LCounter(N,NZ) {
	offer of {
	| #Inc: recv ~N;
		send NZ;
		ICounter(N,NZ)
	| #Dec: recv ~NZ;
		send N;
		ICounter(N,NZ)
	| #Lift: recv ~NZ;
		send N;
		ICounter(N,NZ)
	| #Free: recv ~N;
		wait 
	| #Pack: recv ~N;
		affine 
		send N;
		ICounter(N,NZ)
	}
}
;;


type ICounterINV(N,NZ) {
	affine
	send N;
	ICounter(N,NZ)	
};;

type ICounterADT {   
	sendty N;
	sendty NZ;
	ICounterINV(N,NZ)	
};;

type ICounterRep {
	ICounter(state lint,state lint)
};;


proc rec counterObjOps(c: ICounterRep) {
	affine c;
	case c of {
	| #Inc: recv c (s); // move back
		println "INC";
	  	take s (n);
		put s (n+1);
		send c (s);
		counterObjOps(c)
	| #Dec: recv c (s:~state lint);
		println "DEC";
		take s (n);
		put s (n-1);
		send c (s);
		counterObjOps(c)
	| #Lift:recv c (s);
		send c (s);
		counterObjOps(c)
	| #Free:recv c (s);
		wait c; 
		release s
	| #Pack: recv c (s:~state lint);
		affine c;
		send c (s);
		counterObjOps(c)
	}
};;

proc counterObj(c:ICounterADT) {
	sendty c (state lint);
	sendty c (state lint);
	affine c;
	send c (m. cell m (0));
	counterObjOps(c) 
};;

type LICounterINV(N,NZ) {
	send N;
	ICounter(N,NZ)	
};;

proc sampleusage<N,NZ>( s: ~N, c: ~ICounter(N,NZ), co: send N;ICounter(N,NZ))
{
	#Inc c;
	send c (s);
	recv c (si:~NZ);
	
	#Lift c;  // NZ -> Z
	send c (si);
	recv c (si:~N);
	
	#Inc c;
	send c (si);
	recv c (si:~NZ);
	
	#Dec c;
	send c (si);
	recv c (si:~N);
	
	#Inc c;
	send c (si);
	recv c (si:~NZ);
	
	#Lift c;   // NZ -> Z
	send c (si);
	recv c (si:~N);
	send co (si); fwd c co
};;

proc testLinear()
{
	cut {
		counterObj(c)
		|c:~ ICounterADT |
		recvty c (N);
		recvty c (NZ);
		recv c (s:~N);
	  cut {
		sampleusage<N,NZ>(s, c, co)
		| co: ~send N;ICounter(N,NZ)|
		recv co (si);
		#Free co;
		send co (si);
		close co
	  }
	}
};;


/*

include "examples/state/typestate.nt.clls";;

*/







