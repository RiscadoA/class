/*
    Implements a buffered channel in which receives blocks if the channel is empty.
    The implementation exposes two views: one for sending, another for receiving. 
    Both views can be shared.  
*/ 
include "../pure/maybe.clls";; 

type rec List(A){
    affine{
        choice of {
            |#Nil:  close
            |#Cons: send A; List(A)
        }
    }
};;

type rec Node(A,B){ //A linked list of A's with a base case B  
    choice of {
        |#Null: affine B
        |#Next: send maybe(affine A); LList(A,B)
    }
} and LList(A,B){
    state Node(A,B)
};;


type rec RecvT(A){
    choice of {
        |#Recv:      Cont(A)
        |#Release:   close
        |#Share: send RecvT(A); RecvT(A)
    }
} and Cont(A){
    affine{recv coaffine ~A; RecvT(A)}
};; 

proc rec mrecv<A>(x:~RecvT(A), c:usage ~LList(A, List(Cont(A)))){
    case x of {
        |#Recv: 
        take c(l);
        mrecvAux<A>(l,x,c)

        |#Release: 
        wait x;
        release c 

        |#Share:
        recv x(y);
        share c{
            mrecv<A>(x,c)
            ||
            mrecv<A>(y,c)
        }
    }
} and mrecvAux<A>(l:~LList(A,List(Cont(A))),x:~Cont(A),c:usagel ~LList(A, List(Cont(A)))){
    take l(n);
        case n of{
            |#Null:
            put l(nn.   affine nn;
                        #Null nn;
                        affine nn;
                        affine nn;
                        #Cons nn;
                        send nn(x); 
                        fwd nn n);
            put c(l);
            release c

            |#Next: 
            recv n(a);
            case a of {
                |#Nothing: 
                wait a; 
                share n{
                    put l(nn.   affine nn;
                                #Next nn;
                                send nn(b. #Nothing b; close b);
                                fwd nn n);
                    release l 
                    ||
                    mrecvAux<A>(n, x, c)
                }
                |#Just: 
                send x(a);
                share n{
                    put l(nn.   affine nn;
                                #Next nn;
                                send nn(b. #Nothing b; close b);
                                fwd nn n);
                    release l 
                    ||
                    put c(n);
                    mrecv<A>(x,c)
                }
            }
        }
};; 


type rec SendT(A){
    choice of {
        |#Send:     send affine A; SendT(A)  
        |#Release:  close 
        |#Share:    send SendT(A); SendT(A)
    }
};; 

proc rec msend<A>(x:~SendT(A), c:~state LList(A, List(Cont(A)))){
case x of { 
    |#Send:    
    take c(l); 
    take l(n); 
    recv x(a);
    case n of {
        |#Null: 
        case n of {
            |#Nil: 
            wait n; 
            cut{
                cell l0(n0. affine n0;
                            #Null n0;
                            affine n0; 
                            #Nil n0; 
                            close n0)
                |l0:~LList(A, maybe(Cont(A)))|
                share l0{
                   put c(l0);
                   msend<A>(x,c)
                   ||
                   put l(n. affine n;
                            #Next n;
                            send n(b. #Just b; fwd b a);
                            fwd n l0);
                    release l 
                }
            }
            |#Cons: 
            recv n(cont);
            send cont(a);
            put l(nn.   affine nn;
                        #Null nn;
                        affine nn;
                        fwd nn n); 
            share l{
                put c(l);
                msend<A>(x,c)
                ||
                cut{
                    cell c2(ld. affine ld; fwd ld l) //TODO: issue: if we just write cell c2(l) type system complains
                    |c2:~state LList(A, List(RecvT(A)))|
                    mrecv<A>(n,c2)
                }
            }
        }
        |#Next: //never happens
        par{
        recv n(b);
        case b of {
            |#Nothing:
            wait b; 
            put l(nn.   affine nn;
                        #Next nn;
                        send nn(c. #Nothing c; close c);
                        fwd nn n);
            put c(l);
            msend<A>(x,c)

            |#Just: 
            put l(nn.   affine nn;
                        #Next nn;
                        send nn(c. #Just c; fwd c b);
                        fwd nn n);
            put c(l);
            msend<A>(x,c)
        }
        ||
        discard a}
    }

    |#Release: 
    wait x; 
    release c 

    |#Share: 
    recv x(y);
    share c{
        msend<A>(x,c)
        ||
        msend<A>(y,c)
    }
}
};; 

/*
proc rec sendList<A>(l:~List(affine A), x:SendT(A)){
    case l of {
        |#Nil: 
        wait l;
        #Release x; 
        close x 

        |#Cons: 
        recv l(a);
        sleep 10;
        println("SEND: sending element"); 
        #Send x;
        send x(a);
        sendList<A>(l,x)
    }
};;

proc sendOddN(x:SendT(lint);n:colint){
    cut{
        !f(f0);
        recv f0(a);
        affine f0;
        let f0 a+2 
        |f:?send affine lint;coaffine colint|
        genList<affine lint>(l;1,f,n)
        |l:~List(affine lint)|
        sendList<lint>(l, x)
    }
};;


proc sendEvenN(x:SendT(lint);n:colint){
    cut{
        !f(f0);
        recv f0(a);
        affine f0;
        let f0 a+2 
        |f:?send affine lint;coaffine colint|
        genList<affine lint>(l;0,f,n)
        |l:~List(affine lint)|
        sendList<lint>(l, x)
    }
};;

proc unsafe_rec recvAndPrintN(x:RecvT(lint);n:colint){
    if (n == 0){
        #Release x;
        close x
    }{
        #Recv x; 
        affine x; 
        recv x(a);
        println("RECV: got " + a);
        recvAndPrintN(x;n-1)
    }
};;


proc main(){  
    cut{
        cell l(n.   affine n;
                    #Null n;
                    affine n;
                    #Nothing n;
                    close n)
        |l:~LList(lint, maybe(cont(lint)))|
        share l{
            cut{
                cell c(ld. affine ld; fwd ld l) //TODO: issue: if we just write cell c1(l) type system complains
                |c:~state LList(lint, maybe(cont(lint)))|
                mrecv<lint>(x,c)
                |x:RecvT(lint)|
                recvAndPrintN(x;20)
            }
            ||
            cut{
                cell c(ld. affine ld; fwd ld l) //TODO: issue: if we just write cell c1(l) type system complains
                |c:~state LList(lint, maybe(cont(lint)))|
                msend<lint>(x,c)
                |x:SendT(lint)|
                #Share x;
                send x(y. sendOddN(y;10));
                sendEvenN(x;10)
            }       
        }
    }
};; 
*/