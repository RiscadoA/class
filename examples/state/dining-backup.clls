type rec NAT {
	choice of {
      	|#Z: close
     	|#S:  NAT
    }
};;

proc zero(n:NAT)
{
	#Z n; close n
};;

proc succ(n:NAT, m:~NAT)
{
	#S n; fwd n m
};;


type corec Fork {
    affine offer of {
        |#Pick:
	offer of {
        |#Drop: Fork
    }
    }
};;

type AFork {
    affine offer of {
        |#Pick:
	offer of {
        |#Drop: Fork
    }
    }
};;

proc rec newFork(f:Fork; nam:colstring)
{
	affine f;
	case f of {
        |#Pick: 
		println ("Pick "+nam+"!");
    		case f of {
        		|#Drop: 
			   	println ("Drop "+nam+"!");
				newFork(f;nam)
    			}
    }
};;

type rec LockOrder {
    state Lock
} and Lock {
    send Fork;
    affine
	 choice of {
        |#Null: close
        |#Next: LockOrder
    }
};;


type ALock {
	affine Lock
};;

type rec ELock {
	statel Lock
};;

proc null(v:ALock, f:~Fork) {
	affine v;
	send v (f0:Fork. fwd f f0);
	affine v;
	#Null v;
	close v
};;

proc next(v:ALock, f:~Fork, h:~ALock) {
	affine v;
	send v (f0:Fork. fwd f f0);
	affine v;
	#Next v;
	cell v (nn:ALock. fwd h nn)
};;

proc newOrder(s:LockOrder, f:~Fork) {
	cell s (n:ALock. null(n,f))
};;

proc addOrder(s:~LockOrder, f:~Fork, sr:LockOrder) {
	take s (h: ~ALock );
	put s (n:ALock. next(n,f, h));
	fwd s sr
};;

proc addOrderTR(s:~LockOrder, f:~Fork, sr:send close;LockOrder) {
	take s (h: ~ALock );
	put s (n:ALock. next(n,f, h));
	send sr (x.close x); fwd s sr
};;

proc rec getNthLock(n:~NAT, s: ~LockOrder, lh: LockOrder)
{
  case n of {
   | #Z: wait n; fwd s lh 
   | #S: take s (h: ~ALock );
		recv h (f:~Fork);
		case h of {
			| #Null: wait h; 
			  println ("UNREACHABLE: getNthLockHandle");
			  put s (v:ALock.null(v,f));
			  par { fwd s lh || discard n }
	         | #Next: 
			  share h { 
					getNthLock(n,h,lh)
			     	||
			    		put s (hh:ALock.affine hh;
					send hh (f0:Fork. fwd f f0);
					affine hh;
					#Next hh; fwd hh h);
			    		release s
               }
         }
  }
};;

proc unsafe_rec getNth(n:~!lint, s: ~LockOrder, lh: LockOrder)
{
   if(n==0) {
	  fwd s lh 
   } { take s (h: ~ALock );
		recv h (f:~Fork);
		case h of {
			| #Null: wait h; // never happens
			  println ("UNREACHABLE: getNthLockHandle");
			  put s (v:ALock.null(v,f));
			  fwd s lh 
	         | #Next: 
			  share h { 
					getNth(n-1,h,lh)
			     	||
			    		put s (hh:ALock.affine hh;
					send hh (f0:Fork. fwd f f0);
					affine hh;
					#Next hh; fwd hh h);
			    		release s
               }
         }
    }
};;

proc eat(s: ~LockOrder, lh: LockOrder; nam:colstring )
{
	take s (h1: ~ALock );
	recv h1 (f:~Fork);
	case h1 of {
	| #Null:
		wait h1; // never happens
		println (nam+"UNREACHABLE");
	   	put s (v:ALock.null(v,f));
	   	fwd s lh
	| #Next: 
		take h1 (h2: ~ALock );
		recv h2 (f2:~Fork);
		print (nam+" "); #Pick f;
		print (nam+" "); #Pick f2; 
		println (nam+" got 2"); 
		print (nam+" "); #Drop f; 
		print (nam+" "); #Drop f2; 
		put h1 (n2: ALock. 
				affine n2;
				send n2 (f0:Fork. fwd f2 f0);
				fwd h2 n2);
		put s (n1: ALock. 
				affine n1;
				send n1 (f0:Fork. fwd f f0);
				affine n1;
				#Next n1; fwd h1 n1);
		fwd s lh
    }
};;


proc rec go2(
		   s0:~ELock,
		   v1:~LockOrder,
		   fi: ~Fork,
		   lh: send ELock; send LockOrder; Fork ; 
		   nam:colstring)
{
	take v1 (h1: ~ALock );
	recv h1 (f:~Fork);
	case h1 of {
	| #Null:
		wait h1;
		print (nam+" fi"); #Pick fi;
		print (nam+" f" ); #Pick f; 
		println (nam+" got 2"); 
		sleep 1; // use both
		print (nam+" f"); #Drop f; 
		print (nam+" fi"); #Drop fi; 
		put v1 (v:ALock.null(v,f));
	   	send lh (sh:ELock. fwd s0 sh);
	   	send lh (lh0:LockOrder. fwd v1 lh0);
		fwd fi lh
	| #Next: 
		share h1 {
			go2(s0, h1,fi,lh; nam) 
			||
			put v1 ( n1: ALock. 
			  		affine n1;
			  		send n1 (fn1:Fork. fwd f fn1);
			  		affine n1;
			  		#Next n1; 
			  		fwd n1 h1); release v1
		}
    }
};;

proc eat2X(s: ~LockOrder, lh:LockOrder; nam:colstring) 
{
	take s (h1: ~ALock );
	recv h1 (f:~Fork);
	case h1 of {
	| #Null: // never happens
		wait h1; 
		println (nam+"UNREACHABLE");
	   	put s (v:ALock.null(v,f));
	   	fwd s lh
	| #Next: 
		cut {
		go2 ( s, h1, f, cb; nam)
		| cb : ~ send ELock; send LockOrder; Fork |
		recv cb (s0:~ELock);
		recv cb (sh:~LockOrder);
		put s0 (n1: ALock. 
			  affine n1;
			  send n1 (fn1:Fork. fwd cb fn1);
			  affine n1;
			  #Next n1; 
			  fwd n1 sh);
	    fwd s0 lh
     }
   }	
};;

proc doNPick(s:~LockOrder,ns: LockOrder; a:~lint,nam:~lstring)
{  
	cut {
		!body(sb); recv sb (e); eat(e,sb;nam)
		|body: ?send LockOrder; ~ LockOrder |
		iter<LockOrder>(ns,s;body,a)
	}
};;

proc doNPickS(s:~LockOrder,ns: LockOrder; a:~lint,nam:~lstring)
{
	cut {
		!body(sb);recv sb (e); eat2X(e,sb;nam)
		|body: ?send LockOrder;~ LockOrder |
		iter<LockOrder>(ns,s;body,a)
	}
};;

proc philo(nam:?colstring, s:~ LockOrder;a:colint)
{
	cut {
		doNPick(s,sn; a,nam)
		|sn:~ LockOrder |
	    release sn
	}
};;

proc philX(nam:?colstring, s:~ LockOrder;a:colint)
{
	cut {
		doNPickS(s,sn; a,nam)
		|sn:~ LockOrder |
		release sn
	}
};;

proc philosophers3(;n:~lint)
{
 cut {
	 newFork(f0;"fork3")
	 
	 | f0: ~Fork |
	 
	 newOrder(s0,f0)
	 
    | s0: ~LockOrder |
    
	 newFork(f1;"fork2") | f1: ~Fork | addOrder(s0,f1,s1)
	 
    | s1: ~LockOrder |
    
	 newFork(f2;"fork1") | f2: ~Fork | addOrder(s1,f2, s2)
	 
    | s2: ~LockOrder |
    
	share s2 {
		cut { 
			 getNth(0,s2,s0)
				|s0:~ LockOrder |
			 philo("P1",s0;n) }
		||
		cut { 
			 getNth(1,s2,s1)
			 |s1:~ LockOrder |
			philo("P2",s1;n) }
		||
			philX("P0",s2;n) // symmetry breaker
		} 
    }
};;

proc main() {
	philosophers3(;100)
};;


proc unsafe_rec mkForks(ord:send close;LockOrder;n:~lint)
{
if (n==0) {
    cut {
	 newFork(f;"fork "+n)
	 | f: ~Fork |
	 send ord (x.close x); newOrder(ord,f)
	 }     	 
} 
{
    cut {
    	mkForks(ord_ind;n-1)
   	 | ord_ind: ~send close; LockOrder |
	recv ord_ind (ack);
	wait ack;
	cut {
	    newFork(f;"fork "+(n-1))
	    	| f: ~Fork |
	    addOrderTR(ord_ind,f,ordp)
	        | ordp: ~send close; LockOrder |
	    recv ordp (ack); wait ack;
	    send ord (x.close x); fwd ord ordp
	}     	 
	
    }     	 
  }     
};;


proc unsafe_rec mkPhils(ord:~LockOrder;n:~lint,nphil:~lint)
{
if (nphil==1) {
	philX("P "+(nphil-1),ord;n) // symmetry breaker
} 
{
    cut {
	share ord {
	  cut {
	      getNth(nphil-2,ord,ord_to_me)
	      | ord_to_me:~ LockOrder |
	      philo("P "+(nphil-1),ord_to_me;n) }
	 ||
	 mkPhils(ord;n,nphil-1)
	}     	 
	}     	 
}     
};;


proc mainN(;n:~lint, nphil:~lint)
{
    cut {
	 mkForks(ord;nphil)
   	 | ord: ~send close;LockOrder |
	 recv ord (ack); wait ack;
	 mkPhils(ord;n,nphil)
	 }     	 	 
};;

mainN(;10,10);;

