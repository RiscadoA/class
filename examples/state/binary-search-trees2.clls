
type rec Tree {
        state
        choice of {
            |#Null: close
            |#Node: send { affine !lint };
	    	    affine
	            send affine Tree;
		    affine Tree
        }
};;
   

type Elem{
     choice of {
        |#Null: close
        |#Node: send {affine !lint};
		affine
	        send affine Tree;
		affine Tree
    }
};;

type AElem{
     affine Elem
};;
  
type ATree {
     affine Tree
};;
   
proc null(elem:AElem){
    affine elem;
    #Null elem;
    close elem
};;

proc node(tleft:~ATree, tright:~ATree, elem:AElem ;n:colint){
    affine elem;
    #Node elem;
    send elem(n);		
    affine elem;
    send elem(u:ATree. fwd u tleft);
    fwd elem tright
};;

proc rec iterate(tin:~Tree, tout:Tree) {
    take tin(node:~AElem);
    use node;
    case node of {
        |#Null: put tin(nodee. null(nodee));
		wait node;
		fwd tin tout
        |#Node: recv node(n:coaffine ?colint);
                use n; ?n;
		use node;
		recv node(left0:~ATree);
		cut  {
		     affine tout0;
		     use left0;
		     iterate(left0,tout0)
                     |tout0 : ~ ATree|
		     put tin(nnode.
		     	 affine nnode;
			 #Node nnode; 
			 send nnode (n);
			 affine nnode;
			 send nnode (tout0);
			 fwd nnode node);
		     fwd tin tout
    	   	}		
     }
};;

proc rec find(tin:~Tree, tout:Tree; key:colint) {
    take tin(node:~AElem);
    use node;
    case node of {
        |#Null: put tin(nodee. null(nodee));
		wait node;
		fwd tin tout
        |#Node: recv node(n:coaffine ?colint);
                use n; ?n;
		if (key == n) {
		    put tin (nodee.
		    	affine nodee;
			#Node nodee;
			send nodee(n);
			fwd nodee node);
		    fwd tin tout
    	   	}
		{
		if (key < n) {
		use node;
		recv node(left0:~ATree);
		cut  {
		     affine tout0;
		     use left0;
		     find(left0,tout0;key)
                     |tout0 : ~ ATree|
		     put tin(nnode.
		     	 affine nnode;
			 #Node nnode; 
			 send nnode (n);
			 affine nnode;
			 send nnode (tout0);
			 fwd nnode node);
		     fwd tin tout
    	   	     }
    	   	}
		{
		use node;
		recv node(left0:~ATree);
		cut  {
		     affine tout0;
		     use node;
		     find(node,tout0;key)
                     |tout0 : ~ ATree|
		     put tin(nnode.
		     	 affine nnode;
			 #Node nnode; 
			 send nnode (n);
			 affine nnode;
			 send nnode (left0);
			 fwd nnode tout0);
		     fwd tin tout
    	   	     }
    	   	}
    	   	}
		
     }
};;

proc rec finda(tin:~Tree, tout:ATree; key:colint) {
    take tin(node:~AElem);
    use node;
    case node of {
        |#Null: put tin(nodee. null(nodee));
		wait node;
		affine tout;
		fwd tin tout
        |#Node: recv node(n:coaffine ?colint);
                use n; ?n;
		if (key == n) {
		    put tin (nodee.
		    	affine nodee;
			#Node nodee;
			send nodee(n);
			fwd nodee node);
		    affine tout;
		    fwd tin tout
    	   	}
		{
		if (key < n) {
		use node;
		recv node(left0:~ATree);
		cut  {
		     use left0;
		     finda(left0,tout0;key)
                     |tout0 : ~ ATree|
		     put tin(nnode.
		     	 affine nnode;
			 #Node nnode; 
			 send nnode (n);
			 affine nnode;
			 send nnode (tout0);
			 fwd nnode node);
		     affine tout;
		     fwd tin tout
    	   	     }
    	   	}
		{
		use node;
		recv node(left0:~ATree);
		cut  {
		     use node;
		     finda(node,tout0;key)
                     |tout0 : ~ ATree|
		     put tin(nnode.
		     	 affine nnode;
			 #Node nnode; 
			 send nnode (n);
			 affine nnode;
			 send nnode (left0);
			 fwd nnode tout0);
		     affine tout;
		     fwd tin tout
    	   	     }
    	   	}
    	   	}
		
     }
};;


proc rec finda(tin:~Tree, tout:ATree; key:colint) {
    take tin(node:~AElem);
    use node;
    case node of {
        |#Null: put tin(nodee. null(nodee));
		wait node;
		affine tout;
		fwd tin tout
        |#Node: recv node(n:coaffine ?colint);
                use n; ?n;
		if (key == n) {
		    put tin (nodee.
		    	affine nodee;
			#Node nodee;
			send nodee(n);
			fwd nodee node);
		    affine tout;
		    fwd tin tout
    	   	}
		{
		if (key < n) {
		use node;
		recv node(left0:~ATree);
		cut  {
		     use left0;
		     finda(left0,tout0;key)
                     |tout0 : ~ ATree|
		     put tin(nnode.
		     	 affine nnode;
			 #Node nnode; 
			 send nnode (n);
			 affine nnode;
			 send nnode (tout0);
			 fwd nnode node);
		     affine tout;
		     fwd tin tout
    	   	     }
    	   	}
		{
		use node;
		recv node(left0:~ATree);
		cut  {
		     use node;
		     finda(node,tout0;key)
                     |tout0 : ~ ATree|
		     put tin(nnode.
		     	 affine nnode;
			 #Node nnode; 
			 send nnode (n);
			 affine nnode;
			 send nnode (left0);
			 fwd nnode tout0);
		     affine tout;
		     fwd tin tout
    	   	     }
    	   	}
    	   	}
		
     }
};;

(

proc rec contains(t:~Tree, nt:send Tree;lbool ; k:colint){
    take t(node:~AElem);
    case node of {
        |#Null:
		put t(nodee. null(nodee));
		send nt(t);
		let nt false 
        |#Node:
	        recv node(n:coaffine ?colint);
                use n;
                ?n;
                if(n == k)
                {
		    put t (nodee. affine nodee; #Node nodee;send nodee(n);fwd nodee node);
		    send nt (t);
		    let nt true
                }
		/// HERE
                {
		    recv node(tleft:~ATree);
                    if(k < n)
                    {
                        cut{
			    use tleft;
                            contains(tleft, cres; k)
                            |cres : ~ send Tree;lbool|
			    recv cres(tleft0);
		    	    put t (nodee. affine nodee; #Node nodee;send nodee(n);affine nodee;send nodee(tleft0);fwd nodee node);	    
                            send nt(t);
			    fwd cres nt
                        }
                    }
                    {
                        cut{
                            contains(node, cres; k)
                            |cres : ~ send Tree;lbool|
			    recv cres(elem0);
                            send nt(elem0);
			    fwd cres nt
                        }
                    }
                }
    }
};;

//prints tree in preorder tree walk
proc rec printTreeAux(t:~Tree, nt: send Tree; close){
    take t(elem:coaffine ~Elem);
    use elem;
    case elem of {
        |#Null: wait elem;
                put t(nelem:affine Elem.
                            affine nelem;
                            null(nelem));
                print("NULL");
                send nt(td:Tree. fwd td t);
                close nt

        |#Node: recv elem(a:coaffine ?colint);
                recv elem(tleft:~Tree);
                use a;
                ?a;
                print("(NODE " + a + " ");
                cut{
                    printTreeAux(tleft, x)
                    |x:recv ~Tree; wait|
                    recv x(tleft2:~Tree);
                    wait x;
                    print(" ");
                    cut{
                        printTreeAux(elem, y)
                        |y:recv ~Tree; wait|
                        recv y(elem2:~Tree);
                        wait y;
                        print(")");
                        put t(nelem:affine Elem.
                                    affine nelem;
                                    node(tleft2, elem2, nelem;a));
                        send nt(td:Tree. fwd td t);
                        close nt
                    }
                }
    }
};;

proc printTree(t:~Tree, nt:Tree){
    cut{
        printTreeAux(t,x)
        |x:recv ~Tree; wait|
        recv x(ntd:~Tree);
        wait x;
        println("");
        fwd ntd nt
    }
};;

proc rec insert(t:~Tree, nt:Tree; a:colint){
    take t(elem:coaffine ~Elem);
    use elem;
    case elem of {
        |#Null: wait elem;
                cut{
                    cell tleft(x:   affine Elem.
                                    affine x;
                                    null(x))
                    |tleft:~Tree|
                    put t(nelem:affine Elem.
                                affine nelem;
                                node(tleft, tright, nelem;a));
                    fwd t nt
                    |tright:Tree|
                    cell tright(x:  affine Elem.
                                    affine x;
                                    null(x))
                }

        |#Node: recv elem(b:coaffine ?colint);
                recv elem(tleft:~Tree);
                use b;
                ?b;
                if(a < b)
                {
                    cut{
                        insert(tleft, ntleft; a)
                        |ntleft:~Tree|
                        put t(nelem:affine Elem.
                                    affine nelem;
                                    node(ntleft, elem, nelem; b));
                        fwd t nt
                    }
                }
                {
                    cut{
                        insert(elem,x;a)
                        |x:~Tree|
                        put t(nelem:affine Elem.
                                    affine nelem;
                                    node(tleft, x, nelem;b));
                        fwd t nt
                    }
                }
    }
};;

proc maxThree(max:!lint; a:colint, b:colint, c:colint){
    if (a < b)
    {
        if(b < c)
        {
            let! max c
        }
        {
            let! max c
        }
    }
    {
        if(a < c)
        {
            let! max c
        }
        {
        let! max a
        }
    }
};;


proc rec max(t:~Tree, x: send !lint; send Tree; close){
    take t(elem:coaffine ~Elem);
    use elem;
    case elem of {
        |#Null: wait elem;
                send x(max:!lint. let! max -1);
                put t(nelem:affine Elem.
                            affine nelem;
                            null(nelem));
                send x(td:Tree. fwd td t);
                close x

        |#Node: recv elem(a:coaffine ?colint);
                use a;
                ?a;
                recv elem(tleft:~Tree);
                cut{
                    max(tleft, y)
                    |y:recv ?colint; recv ~Tree; wait|
                    recv y(aleft: ?colint);
                    ?aleft;
                    recv y(ntleft:~Tree);
                    wait y;
                    recv z(aright: ?colint);
                    ?aright;
                    recv z(ntright:~Tree);
                    wait z;
                    send x(max:!lint. maxThree(max;a, aleft, aright));
                    put t(nelem:    affine Elem.
                                    affine nelem;
                                    node(ntleft, ntright, nelem; a));
                    send x(td:Tree. fwd td t);
                    close x

                    |z:send !lint; send Tree; close|
                    max(elem, z)
                }

    }
};;

proc unsafe_rec delete(t:~Tree, nt:Tree; k:colint){
    take t(elem:coaffine ~Elem);
    use elem;
    case elem of {
        |#Null: wait elem;
                put t(nelem:    affine Elem.
                                affine nelem;
                                null(nelem));
                fwd t nt

        |#Node: recv elem(a:coaffine ?colint);
                use a;
                ?a;
                recv elem(tleft:~Tree);
                if(a == k)
                {
                  cut{
                   max(tleft,x)
                   |x:recv ?colint; recv ~Tree; wait|
                   recv x(maxLeft:?colint);
                   recv x(ntleft:~Tree);
                   wait x;
                   ?maxLeft;
                   if(maxLeft == -1)
                   {
                    par{    release ntleft
                            ||
                             put t(nelem:    affine Elem.
                                 affine nelem;
                                 null(nelem));
                             release t
                             ||
                             fwd elem nt

                            }
                   }
                   {
                    cut{
                        delete(ntleft, ntleft2; maxLeft)
                        |ntleft2:~Tree|
                        put t(nelem: affine Elem.
                                    affine nelem;
                                    node(ntleft2,elem, nelem;maxLeft));
                        fwd t nt
                   }



                }
                }}
                {//a!=k
                    cut{
                        delete(tleft, ntleft;k)
                        |ntleft:~Tree|
                        put t(nelem:    affine Elem.
                                        affine nelem;
                                        node(ntleft, ntright, nelem; a));
                        fwd t nt
                        |ntright:Tree|
                        delete(elem, ntright;k)
                    }
                }
    }
};;

proc test1(){
    cut{
        cell t(elem:affine Elem.
                    affine elem;
                    null(elem))
        |t:~Tree|
        printTree(t,nt)
        |nt:~Tree|
        release nt
    }
};;

proc test2(){
    cut{
        cell t(elem:affine Elem.
                    affine elem;
                    null(elem))
        |t:~Tree|
        cut{
            ?a;
            insert(t,t1;a)
            |a:!lint|
            let! a 2
         }
         |t1:~Tree|
         printTree(t1, t2)
         |t2:~Tree|
        release t2
    }
};;

proc test3(){
    cut{
        cell t(elem:affine Elem.
                    affine elem;
                    null(elem))
        |t:~Tree|
        cut{
            ?a;
            insert(t,t1;a)
            |a:!lint|
            let! a 2
         }
         |t1:~Tree|
         cut{
            ?b;
            insert(t1,t2;b)
            |b:!lint|
            let! b 3
         }
         |t2:~Tree|
         printTree(t2, t3)
         |t3:~Tree|
         release t3
    }
};;

proc test4(){
    cut{
        cell t(elem:affine Elem.
                    affine elem;
                    null(elem))
        |t:~Tree|
        cut{
            ?a;
            insert(t,t1;a)
            |a:!lint|
            let! a 2
         }
         |t1:~Tree|
         cut{
            ?b;
            insert(t1,t2;b)
            |b:!lint|
            let! b 3
         }
         |t2:~Tree|
         cut{
            ?c;
            insert(t2,t3;c)
            |c:!lint|
            let! c 1
         }
         |t3:~Tree|
         printTree(t3, t4)
         |t4:~Tree|
         release t4
    }
};;

proc test5(){
    cut{
        cell t(elem:affine Elem.
                    affine elem;
                    null(elem))
        |t:~Tree|
        cut{
            ?a;
            insert(t,t1;a)
            |a:!lint|
            let! a 2
         }
         |t1:~Tree|
         cut{
            ?b;
            insert(t1,t2;b)
            |b:!lint|
            let! b 3
         }
         |t2:~Tree|
         cut{
            ?c;
            insert(t2,t3;c)
            |c:!lint|
            let! c 1
         }
         |t3:~Tree|
         printTree(t3, t4)
         |t4:~Tree|
         max(t4, x)
         |x:recv ?colint; recv ~Tree; wait|
         recv x(n:?colint);
         recv x(t5:~Tree);
         wait x;
         ?n;
         println("max element = " + n);
         release t5
    }
};;

proc test6(){
    cut{
        cell t(elem:affine Elem.
                    affine elem;
                    null(elem))
        |t:~Tree|
        cut{
            ?a;
            insert(t,t1;a)
            |a:!lint|
            let! a 2
         }
         |t1:~Tree|
         cut{
            ?b;
            insert(t1,t2;b)
            |b:!lint|
            let! b 3
         }
         |t2:~Tree|
         cut{
            ?c;
            insert(t2,t3;c)
            |c:!lint|
            let! c 1
         }
         |t3:~Tree|
         printTree(t3, t4)
         |t4:~Tree|
         cut{
            let! k 3
            |k:?colint|
            ?k;
            delete(t4,t5;k)
         }
         |t5:~Tree|
         printTree(t5, t6)
         |t6:~Tree|
         release t6
    }
};;
