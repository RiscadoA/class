/*
    Implements a shared stack ADT using a list, where push inserts an element to the head of
    the list and pop removes (if any) the head element.
*/

include "../../pure/lists-systemF.clls";;

proc mpush<tA>(c:recv ~!tA;send state !list(!tA);close, s:~state !list(!tA)){
     take s(l);
     recv c(a:~!tA);
     ?a;
     ?l;
     cut{
        !nl(nl0:list(!tA));
        call l(l0:~list(!tA));
        cut{
            !a2(y:tA);
            call a(w:~tA);
            fwd w y
            |a2:~!tA|
            cons<!tA>(a2,l0,nl0)
         }
        |nl:~!list(!tA)|
        ?nl;
        put s(nld.  affine nld;
                    !nld(nld0:list(!tA));
                    call nl(nl0:~list(!tA));
                    fwd nl0 nld0
              );
         send c(ns: state !list(!tA). fwd ns s);
        close c
     }
};;

proc mpop<tA>(c:send maybe(!tA);send state  !list(!tA);close, s:~state !list(!tA)){
     take s(l);
     cut{
        outB<tA>(l, x)
        |x:~!toutB(tA)|
        ?x;
        call x(x0:~toutB(tA));
        case x0 of {
            |#None: wait x0;
                    send c(h:   maybe(!tA).
                                #Nothing h;
                                close h
                          );
                    put s(nl.   affine nl;
                                nilB<tA>(nl)
                          );
                    send c(ns:  state !list(!tA).
                                fwd ns s
                          );
                    close c

            |#Some: recv x0(a:~!tA);
                    send c(h:   maybe(!tA).
                                #Just h;
                                fwd h a
                          );
                    ?x0;
                    put s(nl.   affine nl;
                                !nl(nl0:list(!tA));
                                call x0(y:~list(!tA));
                                fwd y nl0
                         );
                    send c(ns:  state !list(!tA).
                                fwd ns s
                          );
                    close c
        }
     }
};;



proc mfree<tA>(c:close, s:~state !list(!tA)) {
     par {release s || close c}
};;

proc mshare<tA>(c:recv state !list(!tA);recv state !list(!tA);~close, s:~state !list(!tA)){
     recv c(s1:state !list(!tA));
     recv c(s2:state !list(!tA));
     wait c;
     share s {fwd s s1 || fwd s s2}
};;

type tMenu(tA, tX) {
     recv ~tX;
     offer of {
		|#Push:	    recv ~!tA;send tX;close
		|#Pop:	    send maybe(!tA);send tX;close
		|#Share:    recv tX; recv tX;wait
		|#Free:	    close
     }
};;

proc menu<tA>(c: tMenu(tA, state !list(!tA))) {
     recv c(s:~state !list(!tA));
     case c of {
      | #Push:   mpush<tA>(c,s)
	  | #Pop:    mpop<tA>(c,s)
	  | #Share:  mshare<tA>(c,s)
	  | #Free:   mfree<tA>(c,s)
     }
};;

type tStack(tA) {
     sendty tX; send !tMenu(tA,tX);tX
};;

proc stack<tA>(s:tStack(tA)) {
     sendty s (state !list(!tA));
     send s (m: !tMenu(tA, state !list(!tA)).    !m(c:tMenu(tA, state !list(!tA)));
		                                        menu<tA>(c));
     cell s (l. affine l;
     	    	!l(x:list(!tA));
		        nil<!tA>(x))
};;

