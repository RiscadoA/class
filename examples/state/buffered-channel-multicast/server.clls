include "../../pure/maybe.clls";;
include "../linked-lists2.clls";;

proc msend<A>(me: recv coaffine ?~A; send state SList(!A); close, tailptr: usage ~SList(!A)){
    recv me(a);
    take tailptr(c);
    take c(l);
    cut{
        cell c2(l)
        |c2:~SList(!A)|
        share c2 {
            put c(l2. cnext<!A>(a,c2,l2));
            release c
            ||
            put tailptr(c2);
            send me(tailptr);
            close me
        }
    }
};;


proc mrecv<A>(m: send maybe(affine !A); send state SList(!A); close, head:usage ~SList(!A)) {
    take head(c);
    take c(l);
    case l of {
        |#Null: wait l;
                put c(l2. nil<!A>(l2));
                put head(c);
                send m(x. nothing<affine !A>(x));
                send m(head);
                close m
        |#Next:
                recv l(b);
                use b;
                ?b;
                share l{
                    cut{
                        affine b1; fwd! b1 b
                        |b1: coaffine ?~A|
                        put c(l2. cnext<!A>(b1,l,l2));
                        release c
                    }
                    ||
                    cut{
                        affine b2; fwd! b2 b
                        |b2:coaffine ?~A|
                        put head(l);
                        send m(x. just<affine !A>(b2, x));
                        send m(head);
                        close m
                    }
                }
    }
};;

proc mfree<A>(m:close, p:usage ~SList(!A)){
    par{release p || close m}

};;

proc mshare<tA>(c:recv state SList(!tA);recv state SList(!tA);~close, eq:~state SList(!tA)){
     recv c(eq1);
     recv c(eq2);
     wait c;
     share eq {fwd eq eq1 || fwd eq eq2}
};;

proc mdup<tA>(c:recv state SList(!tA);recv state SList(!tA);~close, dq:~state SList(!tA)){
     recv c(dq1);
     recv c(dq2);
     take dq(l);
     use l;
     wait c;
     share l {
        put dq(l0. fwd l0 l);
        fwd dq dq1
        ||
        cell dq2(nl. affine nl; fwd nl l)}
};;

type MenuS(tA, tX) {
     recv ~tX;
     offer of {
                |#Send:   recv coaffine ?~tA;send tX;close
                |#Share: recv tX; recv tX;wait
                |#Free:  close
     }
};;

proc menuS<tA>(c: MenuS(tA, state SList(!tA))){
     recv c(eq:~state SList(!tA));
     case c of {
      | #Send:    msend<tA>(c,eq)
      | #Share:  mshare<tA>(c,eq)
	  | #Free:   mfree<tA>(c,eq)
     }
};;

type MenuR(tA,tX) {
     recv ~tX;
     offer of {
                |#Recv:   send maybe( affine !tA);send tX;close
                |#Share: recv tX; recv tX;wait
                |#Dup:   recv tX; recv tX; wait
                |#Free:  close
     }
};;

proc menuR<tA>(c: MenuR(tA, state SList(!tA))){
     recv c(dq:~state SList(!tA));
     case c of {
	  | #Recv:    mrecv<tA>(c,dq)
      | #Share:  mshare<tA>(c,dq)
      | #Dup:    mdup<tA>(c,dq)
	  | #Free:   mfree<tA>(c,dq)
     }
     };;

type SendT(tA){
     sendty tX; send !MenuS(tA,tX); tX
};;

type RecvT(tA){
    sendty tX; send !MenuR(tA,tX); tX
};;

type BChan(tA){
     recv SendT(tA);RecvT(tA)
};;


proc sendP<tA>(e:SendT(tA), ce:~state SList(!tA)){
     sendty e(state SList(!tA));
     send e(c:!MenuS(tA,state SList(!tA)).
              !c(r:MenuS(tA,state SList(!tA)));
              menuS<tA>(r)
            );
     fwd e ce
};;

proc recvP<tA>(e:RecvT(tA), ce:~state SList(!tA)){
     sendty e(state SList(!tA));
     send e(c:!MenuR(tA,state SList(!tA)).
              !c(r:MenuR(tA,state SList(!tA)));
              menuR<tA>(r)
            );
     fwd e ce
};;

proc bchan<tA>(d:BChan(tA)){
     recv d(e:SendT(tA));
     cut {
        cell l(n. nil<!tA>(n))
        |l:~UList(!tA)|
        share l {
            cut{ cell tail(tl:affine SList(!tA). affine tl; unfold tl; fwd tl l) |tail:~state SList(!tA)| sendP<tA>(e, tail) }
            ||
            cut{ cell head(hl:affine SList(!tA). affine hl; unfold hl; fwd hl l) |head:~state SList(!tA)| recvP<tA>(d, head) }
        }
     }
};;

