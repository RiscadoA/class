
type rec SList(A){
    state {
        List(A)
    }
} and List(A) {
    choice of {
        |#Null: close
        |#Next: send {affine A}; SList(A)
    }
};;

type UList(A) {
    state {
        List(A)
    }
  };;
  
proc single<A>(a:coaffine ~A, n:affine List(A)) {
    affine n;
    #Next n;
    send n(a);
    cell n(x. affine x; #Null x; close x)
};;

proc nil<A>(l: affine List (A)){
    affine l;
    #Null l;
    close l
};;

proc cnext<A>(a:coaffine ~A, c:~UList(A), l: affine List(A)){
   affine l;
   #Next l;
   send l(a);
   fwd l c
};;

proc rec append<A>(c:~SList(A), l2:~ affine List(A), c2:SList(A)) {
    take c(l);
    case l of {
        |#Null: wait l;
                put c(l2);
                fwd c c2

        |#Next: recv l(a);
                cut{
                    append<A>(l,l2,x)
                    |x:~SList(A)|
                    put c(y. cnext<A>(a,x,y));
                    fwd c c2
                }
    }
};;


proc insertElemBeginning<A>(a:coaffine ~A,l:~SList(A), nl: SList(A)){
    take l(n);
    cut{
        cell ll(n)
        |ll:~SList(A)|
        put l(nn. cnext<A>(a,ll,nn));
        fwd l nl
    }
};;

proc rec insertElemEnd<A>(l:~SList(A),a:coaffine ~A, nl: SList(A)){
    cut{
        single<A>(a,n)
        |n:coaffine ~List(A)|
        append<A>(l, n, nl)
    }
};;


proc rec printSListInt(l:~SList(!lint), nl:SList(!lint)){
    take l(n);
    case n of {
        |#Null: wait n;
                put l(n. nil<!lint>(n));
                println("");
                fwd l nl
        |#Next: recv n(k:coaffine ?colint);
                print(k + " ");
                cut{
                    printSListInt(n, x)
                    |x:~SList(!lint)|
                    put l(nn. cnext<!lint>(k,x,nn));
                    fwd l nl
                }
    }
};;


proc unsafe_rec SListNto1(l:SList(!lint);a:colint){
    if(a == 0){
        cell l(x. nil<!lint>(x))
    }
    {
        cut{
            SListNto1(x;a-1)
            |x:~SList(!lint)|
            cell l(y. cnext<!lint>(a,x,y))
        }
    }
};;

//auxiliary process for defining insertionSort
proc rec insert(l:~SList(!lint), nn: affine List(!lint); a:colint){
    take l(n);
    case n of {
        |#Null: wait n;
                put l(x. nil<!lint>(x));
                cnext<!lint>(a,l,nn)

        |#Next: recv n(b);
                if(a < b)
                {
                    put l(x.  cnext<!lint>(b,n,x));
                    cnext<!lint>(a,l,nn)

                }
                {
                    put l(x. insert(n,x;a));
                    cnext<!lint>(b,l,nn)
                }
    }
};;


proc rec insertionSort(l:~SList(!lint), nl:SList(!lint)){
    take l(n);
    case n of {
        |#Null: wait n;
                put l(n. nil<!lint>(n));
                fwd l nl

        |#Next: recv n(a:coaffine ?colint);
                cut{
                    insertionSort(n,x)
                    |x:~SList(!lint)|
                    put l(nn. insert(x,nn;a));
                    fwd l nl
                }
    }
};;


proc test0(){
    cut{
        SListNto1(l0;10)
        |l0:~SList(!lint)|
        printSListInt(l0,l1)
        |l1:~SList(!lint)|
        insertionSort(l1, l2)
        |l2:~SList(!lint)|
        printSListInt(l2,l3)
        |l3:~SList(!lint)|
        release l3
    }
};;

proc test1(){
    cut{
        SListNto1(l0;2)
        |l0:~SList(!lint)|
        insertElemEnd<!lint>(l0,5,l1)
        |l1:~SList(!lint)|
        printSListInt(l1, l2)
        |l2:~SList(!lint)|
        release l2
    }
};;

proc test4(){
    cut{
        SListNto1(l0;1)
        |l0:~SList(!lint)|
	release l0
    }
};;


/*
    Concurrent sorted linked list
*/

/*
proc contains(l:~SList(!lint), x:send SList(!lint);send lbool; close; k:colint){
    take l(n:coaffine ~List(!lint));
    use n;
    case n of {
        |#Null: wait n;
                put l(nn: affine nn.
                          nil<!lint>(nn));
                send x (nl:SList(!lint). fwd nl l);
                send x(b:lbool. let b false);
                close x

        |#Next: recv n(a:coaffine ?colint);
                use a;
                ?a;
                if(a < k)
                {
                    cut{
                        recv y(nl:~SList(!lint));
                        put l(nn:   affine List(!lint).
                                    cnext<!lint>(
                        recv
                        contains(n, y;k)
                    }
                }
                {
                    put l(nn:   affine List(!lint).
                                cnext<!lint>(a, n;nn));
                    send x(ld:SList(!lint). fwd ld l);
                    if(k < a)
                    {
                     send x(b:lbool. let b false);
                     close x
                    }
                    {// a == k
                        send x(b:lbool. let b true);
                        close x
                    }
                }


                cut{
                    recv y(
                    |y:send SList(!lint); send lbool; close|
                    contains(n, y;k)
                }

    }
};;
*/
