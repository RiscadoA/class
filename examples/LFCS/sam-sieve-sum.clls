type corec IntStream {
	offer of   {
		|#next: send int; IntStream
		|#stop: close
	}
};;
 
proc rec integersfrom(n: IntStream, k:~int)
{
    case n of   {
      	| #next: n <- k; integersfrom(n,k+1)
	   	| #stop: close n
 	   }	   	   
 };;

type NextIntStream {
	send int; IntStream
};;

proc unsafe_rec filter(fouts:IntStream, fins:~IntStream, n:~int) {
	case fouts of {
		|#next:
			filter_next(fouts, fins, n)
		|#stop:
			#stop fins; wait fins; close fouts
	}
} and filter_next(fouts:NextIntStream, fins:~IntStream, n:~int) {
	#next fins;
	fins -> v;
	if (v%n == 0) {
		filter_next(fouts, fins, n)
	} else {
		fouts <- v;
		filter(fouts, fins, n)
	}
};;


proc rec sieve(souts:IntStream, sins:~IntStream)
 {
	case souts of { 
		|#next:
			#next sins;
			sins -> p;
			souts <- p;
			letc outp:IntStream {
				filter(outp,sins,p)
			};
			sieve(souts, outp)
		|#stop:
			#stop sins; wait sins; close souts
	}
 };;

proc primesN(primes:IntStream)
{
 	letc  n:IntStream {
      integersfrom(n,2)
 	};
    sieve(primes,n)
 };;

proc unsafe_rec printfirstN(il:~IntStream,k:~int)
{
   	if(k==0) {
	  	#stop il; wait il; println("DONE."); ()
	} else {
		#next il; il -> n;
		println(n);
		printfirstN(il,k-1)
   	}
};;

proc main_ss(np:coint)
{
 	letc primes:IntStream {
      primesN(primes)
	};
    printfirstN(primes,np)
 };;

proc main() {
	  	main_ss(5000)
};;
