// shared thread-safe mutable queue 

type rec LList(A){
    state Node(A)
} and Node(A) {
    choice of {
        |#Nil: close
        |#Next: pair affine A; LList(A)
    }
};;

type ANode(A) {
    affine Node(A)
};;

type SList(A) {
    state Node(A)
};;

proc nil<A>(l: ANode(A)) {
    affine l; #Nil l; close l
};;

proc cons<A>(a:~affine A, t:~SList(A), l: ANode(A)){
    affine l;
    #Next l;
    l <- a;
    unfold l;
    fwd l t
};;

type Ptr { state state Node(lint) };;

proc free(p:~statel Node(lint)) {
    put p(c. nil<lint>(c));
    drop p
};;

type Aint { affine lint };;

type Opt(A) {
    affine choice of {
        | #None : close
        | #Some : A
    }
};;

proc None(o:Opt(Aint)) {
    affine o; #None o; close o
};;

proc Some(val:~Aint,o:Opt(Aint)) {
    affine o;#Some o;fwd val o
};;

proc deq( hd:~Ptr, rv:pair Opt(Aint);Ptr) {

    take hd(hp);
    take hp(lh);
    case lh of {
        |#Nil : 
            wait lh;
            put hp(c. nil<lint>(c));
            put hd(hp);
            rv <- { r. None(r) };
            fwd hd rv
        |#Next : 
            recv lh(val);
            rv <- { r. Some(val,r) };
            unfold lh;
            put hd(lh);
            free(hp); fwd hd rv
    }
};;

proc enq(tl:~Ptr, v:~affine lint, tlo:Ptr) {
    take tl(tn);
    take tn(lp);
    letc nn:LList(lint) {
        cell nn (lp)
    };
    share nn {
        put tn(c. cons<lint>(v,nn,c));
        drop tn
    ||
        put tl(nn);
        forward tl tlo
    }
};;

proc printv(v:~Opt(Aint)) {
    case v of {
        | #None: println("NO"); wait v; ()
        | #Some: println(v); ()
    }
};;

proc unsafe_rec deqloop(tl:~Ptr;N:~int) {
    if N==0 then {
        println("DONE_D");
        drop tl
    } else {
        letc tnext:pair Opt(Aint);Ptr { deq(tl,tnext) };
        recv tnext (val);
        printv(val);
        deqloop(tnext;N-1)    
    }
};;

proc unsafe_rec encloop(hd:~Ptr;N:~int) {
    if N==0 then {
        println("DONE_E");
        drop hd
    } else {
        letc hnext:Ptr { enq(hd,N,hnext) };
        encloop(hnext;N-1)    
    }
};;

proc mainloop(;n:~int) {
    letc sn: LList(lint) {
        cell sn (c.nil<lint>(c))
    };
    share sn {
        letc hd:Ptr {
            cell hd (sn)
        };
        deqloop(hd;n)
        ||
        letc tl:Ptr {
            cell tl (sn)
        };
        encloop(tl;n)
    }
};;

proc main() {
	mainloop(;100000)
};;

