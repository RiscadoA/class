type corec Fork {
    affine offer of {
        |#Pick:
	offer of {
        |#Drop: Fork
    }
    }
};;

type AFork { // unfolded
    affine offer of {
        |#Pick:
	offer of {
        |#Drop: Fork
    }
    }
};;

type rec LockOrder {
    state Lock
} and Lock {
    pair AFork;
    affine
	 choice of {
        |#Null: close
        |#Next: LockOrder
    }
};;

type ALockOrder { // unfolded
	state Lock
};;

type ALock {
	affine Lock
};;

type ELock {
	statel Lock
};;

proc rec newFork(f:Fork; nam:colstring)
{
	affine f;
	case f of {
        |#Pick: 
		println ("Pick "+nam+"!");
    		case f of {
        		|#Drop: 
			   		println ("Drop "+nam+"!");
					newFork(f;nam)
    			}
    }
};;


proc null(v:ALock, f:~AFork) {
	affine v;
	send v (f0:AFork. fwd f f0);
	affine v;
	#Null v;
	close v
};;

proc next(v:ALock, f:~AFork, h:~ALock) {
	affine v;
	send v (f0:AFork. fwd f f0);
	affine v;
	#Next v;
	cell v (nn:ALock. fwd h nn)
};;

proc newOrder(s:LockOrder, f:~AFork) {
	unfold s;
	cell s (n:ALock. null(n,f))
};;

proc addOrder(s:~LockOrder, f:~AFork, sr:LockOrder) {
	take s (h: ~ALock );
	put s (n:ALock. next(n,f, h));
    unfold sr;
	fwd s sr
};;

proc unsafe_rec getNth(n:~!lint, s: ~ALockOrder, lh: ALockOrder)
{
   if(n==0) {
	  fwd s lh 
   } { 	take s (h: ~ALock );
		recv h (f:~AFork);
		case h of {
			| #Null: wait h; // never happens
			  println ("UNREACHABLE: getNthLockHandle");
			  put s (v:ALock.null(v,f));
			  fwd s lh 
	         | #Next: 
			  share h { 
					getNth(n-1,h,lh)
			     	||
			    	put s (hh:ALock.affine hh;
						send hh (f0:AFork. fwd f f0);
						affine hh;
						#Next hh;
						unfold hh;
						fwd hh h);
			    	drop s
               }
         }
    }
};;

proc eat(s: ~ALockOrder, lh: ALockOrder; nam:colstring )
{
	take s (h1: ~ALock );
	recv h1 (f:~AFork);
	case h1 of {
	| #Null:
		wait h1; 
		println (nam+"UNREACHABLE");
	   	put s (v:ALock.null(v,f));
	   	fwd s lh
	| #Next: 

		take h1 (h2:~ALock );
		recv h2 (f2:~AFork);
		print (nam+" "); #Pick f;
		print (nam+" "); #Pick f2; 
		println (nam+" got 2"); 
		print (nam+" "); #Drop f; 
		print (nam+" "); #Drop f2;
		unfold f2;
		put h1 (n2: ALock. 
				affine n2;
				send n2 (f0:AFork. fwd f2 f0);
				fwd h2 n2);
		unfold f;
		put s (n1: ALock. 
				affine n1;
				send n1 (f0:AFork. fwd f f0);
				affine n1;
				#Next n1;
				unfold n1;
				fwd h1 n1);
		fwd s lh
    }
};;

proc rec go2(
		   v1:~ALockOrder,
		   fi: ~AFork,
		   lh: send LockOrder; AFork ; 
		   nam:colstring)
{
	take v1 (h1: ~ALock );
	recv h1 (f:~AFork);
	case h1 of {
	| #Null:
		wait h1;
		print (nam+" fi"); #Pick fi;
		print (nam+" f" ); #Pick f; 
		println (nam+" got 2"); 
		sleep 1; // use both
		print (nam+" f"); #Drop f; 
		print (nam+" fi"); #Drop fi;
		unfold f;
		put v1 (v:ALock.null(v,f));
	   	send lh (lh0:LockOrder. unfold lh0; fwd v1 lh0);
		unfold fi;
		fwd fi lh
	| #Next:
		unfold h1;
		share h1 {
			go2(h1,fi,lh; nam) 
			||
			put v1 ( n1: ALock. 
			  		affine n1;
			  		send n1 (fn1:AFork. fwd f fn1);
			  		affine n1;
			  		#Next n1;
					unfold n1;
			  		fwd h1 n1);
			drop v1
		}
    }
};;


proc eat2(s: ~ALockOrder, lh:ALockOrder; nam:colstring) 
{
	take s (h1: ~ALock );
	recv h1 (f:~AFork);
	case h1 of {
	| #Null: // never happens
		wait h1; 
		println (nam+"UNREACHABLE");
	   	put s (v:ALock.null(v,f));
	   	fwd s lh
	| #Next: 
		letc cb : send LockOrder; AFork {
			go2 ( h1, f, cb; nam) };
		recv cb (sh:~LockOrder);
		unfold sh;
		put s (n1: ALock. 
			  affine n1;
			  send n1 (cb);
			  affine n1;
			  #Next n1; 
			  unfold n1;
			  fwd n1 sh);
	    fwd s lh
     }	
};;


proc unsafe_rec doNPick(s:~ALockOrder,ns: ALockOrder; a:~lint, nam:~lstring)
{  
	if (a==0) {
		println("done!"+nam);
		fwd s ns
	} else { 
        println(nam+" round "+a);
		letc sb:ALockOrder { eat(s,sb;nam) };
		sleep 10; doNPick(sb,ns;a-1,nam)
	}
};;

proc unsafe_rec doNPickS(s:~ALockOrder,ns: ALockOrder; a:~lint, nam:~lstring)
{  
	if (a==0) {
		println("done!"+nam);
		fwd s ns
	} else { 
        println(nam+" round "+a);
		letc sb:ALockOrder { eat2(s,sb;nam) };
		sleep 10; doNPickS(sb,ns;a-1,nam)
	}
};;

proc philo(nam:?colstring, s:~ LockOrder;a:colint)
{
	letc sn:LockOrder {
		doNPick(s,sn; a,nam) };
	drop sn
};;

// symmetry breaker
proc philoSM(nam:?colstring, s:~ ALockOrder;a:colint)
{
	letc sn:LockOrder {
		doNPickS(s,sn; a,nam) };
	drop sn
};;

proc addOrderTR(s:~LockOrder, f:~Fork, sr:send close;LockOrder) {
	take s (h: ~ALock );
	unfold f;
	put s (n:ALock. next(n,f, h));
	send sr (x.close x);
    unfold sr;
	fwd s sr
};;

proc unsafe_rec mkForks(ord:send close;LockOrder;n:~lint)
{
    println("makeF "+n);
    if (n==0) {
        letc f: Fork { newFork(f;"fork "+n) };
	    ord <- { x.close x };
        newOrder(ord,f)
    } else {
        letc ord_ind: send close; LockOrder {
            mkForks(ord_ind;n-1)
        };
        ord_ind -> ack; wait ack;
	    letc f: Fork { newFork(f;"fork "+n) };
        letc ordp: send close; LockOrder { addOrderTR(ord_ind,f,ordp) };
	    ordp -> ack; wait ack;
	    ord <- { x.close x };
	    // unfold ord;
	    // unfold ordp;
	    fwd ord ordp	
    }     	 
};;


proc unsafe_rec mkPhils(ord:~ALockOrder;n:~lint,nphil:~lint)
{
    println("makeP "+n);
    if (nphil==1) {
	    philoSM("P "+(nphil-1),ord;n) // last phil, symmetry breaker
    } 
    {
        share ord {
            letc nth_handle: LockOrder {
                getNth(nphil-2,ord,nth_handle)
            };
            philo("P "+(nphil-1),nth_handle;n) 
        ||
            mkPhils(ord;n,nphil-1)
        }     	 
    }     
};;

proc mainN(; n:~lint, nphil:~lint)
{
    letc ord: send close;LockOrder { mkForks(ord;nphil) };
	ord -> ack; wait ack;
	mkPhils(ord;n,nphil)	 	 
};;

proc main() {
	mainN(;100,5)
};;

