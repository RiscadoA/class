type corec Fork {
    affine offer of {
        |#Pick:
	offer of {
        |#Drop: Fork
    }
    }
};;

type AFork {
    affine offer of {
        |#Pick:
	offer of {
        |#Drop: Fork
    }
    }
};;

type rec LockOrder {
    state Lock
} and Lock {
    pair AFork;
    affine
	 choice of {
        |#Null: close
        |#Next: LockOrder
    }
};;

type ALockOrder { // unfolded
	state Lock
};;

proc rec newFork(f:Fork; nam:colstring)
{
	println("newFork "+nam);
	affine f;
	case f of {
        |#Pick: 
		println ("Pick "+nam+"!");
    		case f of {
        		|#Drop: 
			   	println ("Drop "+nam+"!");
				newFork(f;nam)
    			}
    }
};;

type ALock {
	affine Lock
};;

type ELock {
	statel Lock
};;

proc null(v:ALock, f:~AFork) {
	affine v;
	send v (f0:AFork. fwd f f0);
	affine v;
	#Null v;
	close v
};;

proc next(v:ALock, f:~AFork, h:~ALock) {
	affine v;
	send v (f0:AFork. fwd f f0);
	affine v;
	#Next v;
	cell v (nn:ALock. fwd h nn)
};;

proc newOrder(s:LockOrder, f:~AFork) {
	unfold s;
	cell s (n:ALock. null(n,f))
};;

proc addOrder(s:~LockOrder, f:~AFork, sr:LockOrder) {
	take s (h: ~ALock );
	put s (n:ALock. next(n,f, h));
    unfold sr;
	fwd s sr
};;

proc addOrderTR(s:~LockOrder, f:~Fork, sr:send close;LockOrder) {
	take s (h: ~ALock );
	put s (n:ALock. next(n,f, h));
	send sr (x.close x);
        unfold sr;
	fwd s sr
};;

proc unsafe_rec getNth(n:~!lint, s: ~ALockOrder, lh: ALockOrder)
{
   if(n==0) {
	  fwd s lh 
   } { 	take s (h: ~ALock );
		recv h (f:~AFork);
		case h of {
			| #Null: wait h; // never happens
			  println ("UNREACHABLE: getNthLockHandle");
			  put s (v:ALock.null(v,f));
			  fwd s lh 
	         | #Next: 
			  share h { 
					getNth(n-1,h,lh)
			     	||
			    		put s (hh:ALock.affine hh;
					send hh (f0:AFork. fwd f f0);
					affine hh;
					#Next hh; unfold hh; fwd hh h);
			    		release s
               }
         }
    }
};;

proc eat(s: ~ALockOrder, lh: ALockOrder; nam:colstring )
{
	take s (h1: ~ALock );
	recv h1 (f:~AFork);
	case h1 of {
	| #Null:
		wait h1; // never happens
		println (nam+"UNREACHABLE");
	   	put s (v:ALock.null(v,f));
	   	fwd s lh
	| #Next: 
		take h1 (h2: ~ALock );
		recv h2 (f2:~AFork);
		print (nam+" "); #Pick f;
		print (nam+" "); #Pick f2; 
		println (nam+" got 2"); 
		print (nam+" "); #Drop f; 
		print (nam+" "); #Drop f2;
		unfold f2;
		unfold f;
		put h1 (n2: ALock. 
				affine n2;
				send n2 (f0:AFork. fwd f2 f0);
				fwd h2 n2);
		put s (n1: ALock. 
				affine n1;
				send n1 (f0:AFork. fwd f f0);
				affine n1;
				#Next n1;
				unfold n1;
				fwd h1 n1);
		fwd s lh
    }
};;

proc rec go2(
		   v1:~LockOrder,
		   fi: ~AFork,
		   lh: send LockOrder; AFork ; 
		   nam:colstring)
{
	take v1 (h1: ~ALock );
	recv h1 (f:~AFork);
	case h1 of {
	| #Null:
		wait h1;
		print (nam+" fi"); #Pick fi;
		print (nam+" f" ); #Pick f; 
		println (nam+" got 2"); 
		sleep 1; // use both
		print (nam+" f"); #Drop f; 
		print (nam+" fi"); #Drop fi;
		unfold f;
		put v1 (v:ALock.null(v,f));
	   	send lh (lh0:LockOrder. unfold lh0; fwd v1 lh0);
		unfold fi;
		fwd fi lh
	| #Next:
	        clltype h1;
		unfold h1;
		share h1 {
			go2(h1,fi,lh; nam) 
			||
			put v1 ( n1: ALock. 
			  		affine n1;
			  		send n1 (fn1:AFork. fwd f fn1);
			  		affine n1;
			  		#Next n1;
					unfold n1;
			  		fwd n1 h1); release v1
		}
    }
};;


proc eat2X(s: ~ALockOrder, lh:ALockOrder; nam:colstring) 
{
	take s (h1: ~ALock );
	recv h1 (f:~AFork);
	case h1 of {
	| #Null: // never happens
		wait h1; 
		println (nam+"UNREACHABLE");
	   	put s (v:ALock.null(v,f));
	   	fwd s lh
	| #Next: 
		cut {
		go2 ( h1, f, cb; nam)
		| cb : ~ send LockOrder; AFork |
		recv cb (sh:~LockOrder);
		unfold sh;
		put s (n1: ALock. 
			  affine n1;
			  send n1 (fn1:AFork. fwd cb fn1);
			  affine n1;
			  #Next n1; 
			  unfold n1;
			  fwd n1 sh);
	        fwd s lh
     }
   }	
};;


proc doNPick(s:~ALockOrder,ns: ALockOrder; a:~lint,nam:~lstring)
{  
	cut {
		!body(sb); recv sb (e); eat(e,sb;nam)
		|body: ?send ALockOrder; ~ ALockOrder |
		iter<ALockOrder>(ns,s;body,a)
	}
};;

proc doNPickS(s:~ALockOrder,ns: ALockOrder; a:~lint,nam:~lstring)
{
	cut {
		!body(sb);recv sb (e); eat2X(e,sb;nam)
		|body: ?send ALockOrder;~ ALockOrder |
		iter<ALockOrder>(ns,s;body,a)
	}
};;

proc philo(nam:?colstring, s:~ LockOrder;a:colint)
{
	cut {
		doNPick(s,sn; a,nam)
		|sn:~ LockOrder |
	    release sn
	}
};;

proc philX(nam:?colstring, s:~ ALockOrder;a:colint)
{
	cut {
		doNPickS(s,sn; a,nam)
		|sn:~ LockOrder |
		release sn
	}
};;


proc philosophers3(;n:~lint)
{
 cut {
	 newFork(f0;"fork3")
	 
	 | f0: ~Fork |
	 
	 newOrder(s0,f0)
	 
    | s0: ~LockOrder |
    
	 newFork(f1;"fork2") | f1: ~Fork | addOrder(s0,f1,s1)
	 
    | s1: ~LockOrder |
    
	 newFork(f2;"fork1") | f2: ~Fork | addOrder(s1,f2, s2)
	 
    | s2: ~LockOrder |

        unfold s2;
	share s2 {
		cut { 
			 getNth(0,s2,s0)
				|s0:~ LockOrder |
			 philo("P1",s0;n) }
		||
		cut { 
			 getNth(1,s2,s1)
			 |s1:~ LockOrder |
			philo("P2",s1;n) }
		||
			philX("P0",s2;n) // symmetry breaker
		} 
    }
};;

proc main() {
	philosophers3(;100)
};;


proc unsafe_rec mkForks(ord:send close;LockOrder;n:~lint)
{
println("makeF "+n);
if (n==0) {
    cut {
	 newFork(f;"fork "+n)
	 | f: ~Fork |
	 send ord (x.close x);
	 newOrder(ord,f)
	 }     	 
} 
{
    cut {
    	mkForks(ord_ind;n-1)
   	 | ord_ind: ~send close; LockOrder |
	recv ord_ind (ack);
	println("recv ord_ind ");
	wait ack;
	cut {
	    newFork(f;"fork "+n)
	    	| f: ~Fork |
	    addOrderTR(ord_ind,f,ordp)
	        | ordp: ~send close; LockOrder |
	    recv ordp (ack);
	    wait ack;
	    send ord (x.close x);
	    unfold ord;
	    unfold ordp;
	    fwd ord ordp
	}     	 
	
    }     	 
  }     
};;


proc unsafe_rec mkPhils(ord:~ALockOrder;n:~lint,nphil:~lint)
{
    println("makeP "+n);
if (nphil==1) {
	philX("P "+(nphil-1),ord;n) // symmetry breaker
} 
{
    cut {
	share ord {
	  cut {
	      getNth(nphil-2,ord,ord_to_me)
	      | ord_to_me:~ LockOrder |
	      philo("P "+(nphil-1),ord_to_me;n) }
	 ||
	 mkPhils(ord;n,nphil-1)
	}     	 
	}     	 
}     
};;


proc mainN(; n:~lint, nphil:~lint)
{
    cut {
	 mkForks(ord;nphil)
   	 | ord: ~send close;LockOrder |
	 recv ord (ack);
	 sleep 100;
	 wait ack;
	 mkPhils(ord;n,nphil)
	 }     	 	 
};;

// mainN(;5,5);;


