type corec Fork {
    affine offer of {
        |#Pick:
	offer of {
        |#Drop: Fork
    }
    }
};;

type AFork { // unfolded
    affine offer of {
        |#Pick:
	offer of {
        |#Drop: Fork
    }
    }
};;

type rec LockOrder {
    state Lock
} and Lock {
    pair AFork;
    affine
	 choice of {
        |#Null: close
        |#Next: LockOrder
    }
};;

type ALockOrder { // unfolded
	state Lock
};;

type ALock {
	affine Lock
};;

type ELock {
	statel Lock
};;

proc rec newFork(f:Fork; nam:colstring)
{
	affine f;
	case f of {
        |#Pick: 
		println ("Pick "+nam+"!");
    		case f of {
        		|#Drop: 
			   		println ("Drop "+nam+"!");
					newFork(f;nam)
    			}
    }
};;


proc null(v:ALock, f:~AFork) {
	affine v;
	v <- f;
	affine v;
	#Null v;
	close v
};;

proc next(v:ALock, f:~AFork, h:~ALock) {
	affine v;
	v <- f;
	affine v;
	#Next v;
	cell v (h)
};;

proc newOrder(s:LockOrder, f:~AFork) {
	unfold s;
	cell s (n:ALock. null(n,f))
};;

proc addOrder(s:~LockOrder, f:~AFork, sr:LockOrder) {
	take s (h: ~ALock );
	put s (n:ALock. next(n,f, h));
    unfold sr;
	fwd s sr
};;

proc unsafe_rec getNth(n:~!lint, s: ~ALockOrder, lh: ALockOrder)
{
   if(n==0) {
	  fwd s lh 
   } { 	take s (h: ~ALock );
		h -> f;
		case h of {
			| #Null: wait h; // never happens
			  println ("UNREACHABLE: getNthLockHandle");
			  put s (v:ALock.null(v,f));
			  fwd s lh 
	         | #Next: 
			  share h { 
					getNth(n-1,h,lh)
			     	||
			    	put s (hh:ALock.affine hh;
						hh <- f;
						affine hh;
						#Next hh;
						unfold hh;
						fwd hh h);
			    	drop s
               }
         }
    }
};;

proc eat(s: ~ALockOrder, lh: ALockOrder; nam:colstring )
{
	take s (h1: ~ALock );
	h1 -> f;
	case h1 of {
	| #Null:
		wait h1; 
		println (nam+"UNREACHABLE");
	   	put s (v:ALock.null(v,f));
	   	fwd s lh
	| #Next: 

		take h1 (h2:~ALock );
		h2 -> f2;
		print (nam+" "); #Pick f;
		print (nam+" "); #Pick f2; 
		println (nam+" got 2"); 
		print (nam+" "); #Drop f; 
		print (nam+" "); #Drop f2;
		unfold f2;
		put h1 (n2: ALock. 
				affine n2;
				n2 <- f2;
				fwd h2 n2);
		unfold f;
		put s (n1: ALock. 
				affine n1;
				n1 <- f; 
				affine n1;
				#Next n1;
				unfold n1;
				fwd h1 n1);
		fwd s lh
    }
};;

proc rec go2(
		   v1:~ALockOrder,
		   fi: ~AFork,
		   lh: send LockOrder; AFork ; 
		   nam:colstring)
{
	take v1 (h1: ~ALock );
	h1 -> f;
	case h1 of {
	| #Null:
		wait h1;
		print (nam+" fi"); #Pick fi;
		print (nam+" f" ); #Pick f; 
		println (nam+" got 2"); 
		sleep 1; // use both forks fi,f for a while
		print (nam+" f"); #Drop f; 
		print (nam+" fi"); #Drop fi;
		unfold f;
		put v1 (v:ALock.null(v,f));
	   	send lh (lh0:LockOrder. unfold lh0; fwd v1 lh0);
		unfold fi;
		fwd fi lh
	| #Next:
		unfold h1;
		share h1 {
			go2(h1,fi,lh; nam) 
			||
			put v1 ( n1: ALock. 
			  		affine n1;
			  		n1 <- f;
			  		affine n1;
			  		#Next n1;
					unfold n1;
			  		fwd h1 n1);
			drop v1
		}
    }
};;


proc eat2(s: ~ALockOrder, lh:ALockOrder; nam:colstring) 
{
	take s (h1: ~ALock );
	recv h1 (f:~AFork);
	case h1 of {
	| #Null: // never happens
		wait h1; 
		println (nam+"UNREACHABLE");
	   	put s (v:ALock.null(v,f));
	   	fwd s lh
	| #Next: 
		letc cb : send LockOrder; AFork {
			go2 ( h1, f, cb; nam) };
		recv cb (sh:~LockOrder);
		unfold sh;
		put s (n1: ALock. 
			  affine n1;
			  send n1 (cb);
			  affine n1;
			  #Next n1; 
			  unfold n1;
			  fwd n1 sh);
	    fwd s lh
     }	
};;


proc unsafe_rec doNPick(s:~ALockOrder,ns: ALockOrder; a:~lint, nam:~lstring)
{  
	if (a==0) {
		println("done!"+nam);
		fwd s ns
	} else { 
		letc sb:ALockOrder { eat(s,sb;nam) };
		sleep 10; doNPick(sb,ns;a-1,nam)
	}
};;

proc unsafe_rec doNPickS(s:~ALockOrder,ns: ALockOrder; a:~lint, nam:~lstring)
{  
	if (a==0) {
		println("done!S");
		fwd s ns
	} else { 
		letc sb:ALockOrder { eat2(s,sb;nam) };
		sleep 10; doNPickS(sb,ns;a-1,nam)
	}
};;

proc philo(nam:?colstring, s:~ LockOrder;a:colint)
{
	letc sn:LockOrder {
		doNPick(s,sn; a,nam) };
	drop sn
};;

// symmetry breaker
proc philoSM(nam:?colstring, s:~ ALockOrder;a:colint)
{
	letc sn:LockOrder {
		doNPickS(s,sn; a,nam) };
	drop sn
};;


proc philosophers3(;n:~lint)
{
	letc f0:Fork { newFork(f0;"fork0") };
	letc s0:LockOrder { newOrder(s0,f0) };
	letc f1:Fork { newFork(f1;"fork1") };
	letc s1:LockOrder { addOrder(s0,f1,s1) };
	letc f2:Fork { newFork(f2;"fork2") };
	letc s2:LockOrder { addOrder(s1,f2,s2) };
	share s2 {
		letc h0: LockOrder { getNth(0,s2,h0) };
		sleep 100;
		philo("P1",h0;n) 
		||
		letc h1: LockOrder { getNth(1,s2,h1) };
		sleep 100;
		philo("P2",h1;n)
		||
		sleep 100;
		philoSM("P0",s2;n) 
	} 
	
};;

proc main() {
	philosophers3(;100)
};;

