include "booleans.clls";;

/*
    We define a boolean server that, on request, either:
        discards a boolean (option #dis)
        prints a boolean (option #print)
        computes the logical negation of an inputted boolean (option #neg)
        computes the logical conjunction of two inputted booleans (option #conj)
*/
type Menu{
    offer of {
        |#free:      recv ~bool; close
        |#print:    recv ~bool; close
        |#neg:      recv ~bool; send bool; close
        |#conj:     recv ~bool; recv ~bool; send bool; close
    }
};;

proc server (s:!Menu){
    !s(c:Menu);
    case c of {
        |#free: recv c(x:~bool);
                par{ discard_(x) || close c}

        |#print: recv c(x:~bool);
                 par {print_(x) || close c}

        |#neg:  recv c(x:~bool);
                send c(y:bool. not(x,y));
                close c

        |#conj: recv c(x:~bool);
                recv c(y:~bool);
                send c(z:bool. and_(x,y,z));
                close c
    }
};;

/*
    We define a client that calls the boolean server
    to compute  the logical negation of the boolean false and
    then prints the result.
*/
proc client1(;s:~Menu){
     call s(c0:~Menu);
    #neg c0;
    send c0(x:bool. false_(x));
    recv c0(y:~bool);
    wait c0;
    println("Client 1 got: ");
    print_(y)
};;

/*
    We define a client that calls the boolean server
    to compute  the logical conjunction of the booleans true and false and
    then prints the result.
*/
proc client2(;s:~Menu){
    call s(c0:~Menu);
    #conj c0;
    send c0(x:bool. true_(x));
    send c0(y:bool. false_(y));
    recv c0(z:~bool);
    wait c0;
    println("Client 2 got: ");
    print_(z)
};;

proc client3(;s:~Menu){
    call s(c0:~Menu);
    #free c0;
    send c0(x:bool. true_(x));
    wait c0;
    ()
};;

/*
    Finally, we define a closed process that composes the two clients,
    running in parallel, with the boolean server.

    Independently of the order in which requests are processed by the server,
    both clients will always get the same result.

    Thus, when running system() one observes a permutation of the two strings:
    "Client1: got True" and "Client2: got False".

     There is no "real" concurrency here since the server is stateless.
*/

proc system_bool(){
    cut{ server(s) |s:?~Menu| ?s;par{client1(;s) || client2(;s) || client3(;s) }}
};;
