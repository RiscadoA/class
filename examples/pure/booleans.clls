/*
    We show how the booleans can be encoded as processes in our session-typed language. Besides defining
    the linear boolean constants false_ and true_, we also define some processes that operate on booleans,
    namely: discard, not and and_. This follows Example 2.2. (Linear Booleans) of the paper.

     We then conclude with the definition of the persistent booleans trueB and falseB.
*/


/*
    A boolean is a session that offers a choice between two labels (#F for false and #T for true)
     and then terminates. We first define type bool and then the boolean processes false_ and true_.
*/
type bool{
    choice of {
        |#F: close
        |#T: close
    }
};;


proc false_(bf:bool){
     #F bf;
     close bf
};;

proc true_(bt:bool){
     #T bt;
     close bt
};;


/*
    Process discard consumes a linear boolean on session b. It performs a case analysis on the selected label,
    waits and continues as the inaction process ().
*/
proc discard_(b:~bool){
     case b of {
        |#F: wait b;()
        |#T: wait b;()
     }
};;

/*
    Defines a processes that prints a linear boolean.
*/
proc print_(b:~bool){
    case b of {
        |#F: wait b; println("False"); ()
        |#T: wait b; println("True"); ()
    }
};;

/*
    Process not consumes a linear boolean on session x and produces its negated form on session y.
*/
proc not(x:~bool, y:bool){

     case x of {
        |#F:      println("--- not #F");
		  wait x;
               	   true_(y)
	    |#T:    wait x;
	            false_(y)
     } 
};;

/*
    Process and_ consumes linear booleans x and y and produces their logical conjunction on session z.
*/

proc and_(x:~bool, y:~bool, z:bool){
     case x of {
     	|#F:    wait x;
     	        par { discard_(y)  || false_(z) } //When x is false, y is discarded and, in parallel, z is false.
	    |#T:    wait x;
	            fwd y z // In case x is true, the output will be y (y and z are linked).
	 }
};;

/*
    Promotes a boolean to affine boolean.
*/
proc affBool(x:~bool, y:affine bool){
    case x of {
        |#F: wait x; affine y; false_(y)
        |#T: wait x; affine y; true_(y)
    }
};;

/*
    The persistent booleans are encoded as trueB and falseB. They are replicated servers that persistently offer
    the linear booleans true_ and false_.
*/
proc trueB(b:!bool){
    !b(b0:bool);true_(b0)
};;

proc falseB(b:!bool){
    !b(b0:bool); false_(b0)
};;

/*
    Test: should print "False".
*/
proc notTrue(){
    cut{ true_(x) |x:~bool| not(x,y) |y:~bool| print_(y)}
};;

/*
    Test: should print "True".
*/
proc notFalse(){
    cut{ false_(x) |x:~bool| not(x,y) |y:~bool| print_(y)}
};;


/*
    Test: should print "True".
*/
proc andTrueTrue(){
    cut{true_(x) |x:~bool| cut { true_(y) |y:~bool| and_(x,y,z) |z:~bool| print_(z)}}
};;

/*
    Test: should print "False".
*/
proc andFalseTrue(){
    cut{false_(x) |x:~bool| cut { true_(y) |y:~bool| and_(x,y,z) |z:~bool| print_(z)}}
};;

/*
    Test: should print "False".
*/
proc andTrueFalse(){
    cut{true_(x) |x:~bool| cut { false_(y) |y:~bool| and_(x,y,z) |z:~bool| print_(z)}}
};;

/*
    Test: should print "False".
*/
proc andFalseFalse(){
    cut{false_(x) |x:~bool| cut { false_(y) |y:~bool| and_(x,y,z) |z:~bool| print_(z)}}
};;

