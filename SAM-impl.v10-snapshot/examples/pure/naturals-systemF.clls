/*
    We implement the naturals with polymorphic sessions. The implementation of the nat datatype together with processes
    zero, succ and iszero follow example 2.4. of the paper.
*/


type fun(a,b) {
     recv ~ a; b
};;

/*
    Terms of type nat receive a type variable tX, a value z:tX and a server s:!fun(tX,tX), and call the s a finite
    (possibly zero) number of times on z to return a value n:tX.
*/
type nat {
recvty tX; recv ~ tX; recv ~ ! fun(tX,tX) ; tX
};;


/*
    Process zero simply forwards z on n without calling the server s.
*/
proc zero(n:nat) {
recvty n (tX);
recv n (z : ~ tX) ;
recv n (s: ~ ! fun(tX,tX)) ;
?s;
fwd z n
};;

/*
    Process succ calls the server one more time on the output produced by the calls of n.
*/
proc succ(n:~nat, m: nat) {
     recvty m (tX);
     recv m (z: ~ tX);
     recv m (s : ~ !fun(tX,tX)) ;
     ?s;
     sendty n
      (tX);
     send n (w: tX. fwd z w);
     send n (g: !fun(tX,tX).
          !g(r:fun(tX,tX));
          call s (r2: ~ fun(tX,tX));
          fwd r2 r) ;
     call s(r:~ fun(tX,tX));
     send r (sn: tX. fwd n sn);
     fwd r m
};;

/*
    We now illustrate how we can define recursive operations on naturals, by encoding the predicate iszero(n,b) that
    consumes a natural n and produces a linear boolean b true if n is zero, and false otherwise.

    We first define an auxiliar process kfalse that outputs false regardless of the input and which will correspond to
    the server s in the inductive definition of iszero.
*/

include "booleans.clls";;

proc kfalse(s:!fun(bool,bool)){
     !s(s0:fun(bool,bool));
     recv s0(b:~bool);
     par { discard_(b) || false_(s0)} //the server discards its received input b and outputs false
};;


proc iszero(n:~nat, b:bool){
     sendty n (bool); // we instantiate natural n with type bool
     send n (z:bool. true_(z)); // the zero case corresponds to the boolean true
     send n (s:!fun(bool, bool). kfalse(s)); // the server is kfalse
     fwd n b // we forward the ouput produced by n on b
};;


/*
    We now define some basic tests, namely processes iszero_zero and iszero_one that compose the natural n zero and
    one, respectively, with predicate iszero(n,b) and print the outputed boolean b. You should expect to see a true and
    false, respectively.

*/

proc p(){
  cut{ cut{ zero(n) |n:~nat| iszero(n,b)}
        |b:~bool|
        discard_(b)}
};;

proc q(){
  cut{ cut{ cut {zero(z) |z:~nat| succ(z,o)}
        |o:~nat| iszero(o,b)}
        |b:~bool|
        discard_(b)}
};;



type toutn{
     choice of {
          |#Zero: close 
          |#Succ: nat
     }
};;


proc out(n:~nat, v:toutn){
     sendty n (toutn);
     send n( z:toutn.
	     #Zero z; close z
	   );
     send n( s:!fun(toutn, toutn).
     	     !s(f:fun(toutn, toutn));
	     recv f(x: ~toutn);
	     #Succ f; 
	     case x of {
	     	  |#Zero: wait x; zero(f)
		  |#Succ: succ(x,f) 
	     }
	    );
      fwd n v 
};;

proc disfun(f:~fun(nat,bool)){
     send f(z:nat. zero(z));
     discard_(f) 
};;


proc equal(n:~nat, m:~nat, b:bool){
     sendty n(fun(nat,bool));
     send n( z:fun(nat, bool).
     	       recv z(k:~nat);
	       iszero(k, z)
	     );
     send n( s:!fun(fun(nat,bool), fun(nat,bool)).
     	     !s(g:fun(fun(nat,bool), fun(nat,bool)));
	     recv g(f:~fun(nat,bool));
	     recv g(k:~nat);
	     cut { out(k,x) |x:~toutn|
	     	   case x of {
		   	|#Zero: wait x; par {disfun(f) || false_(g)}
			|#Succ: send f(xc:nat. fwd xc x); fwd f g 
		   }
		 }
	   );
      send n(mc:nat. fwd mc m);
      fwd n b 
};;

