type rec LAsset {
	choice of {
	|#One : LAsset
	|#Empty : close
	}
};;

type Bool {
	choice of {
	|#T : close
	|#F : close
	}
};;

type rec Nat { 
	coaffine
	choice of {
	|#S : Nat
	|#Z : close
	}
};;

proc true(b:Bool) {
	#T b; close b
};;

proc false(b:Bool) {
	#F b; close b
};;

proc zero(z:Nat) {
	#Z z; close z
};;

proc succ(n:~Nat,s:Nat) {
	#S s;fwd s n
};;

proc succ(n:Nat) returns (s:Nat) {
	#S s;fwd s n
};;

proc rec drop(n:~Nat) {
	 case n of {
	 |#Z : wait n; ()
     |#S : drop (n)
     }
};;

proc rec extract (q: ~Nat, a: ~LAsset, ra:send LAsset;send LAsset; close) {
	case q of {
	|#Z : send ra (a); send ra (y. #Empty y; close y); wait q; close ra
	|#S  : case a of {
		 |#One: cut {
				extract(q,a,raa)
				|raa:~send LAsset;send LAsset; close|
				recv raa (x0);
				recv raa (y0);
				send ra (x1.#One x1; fwd x0 x1);
				send ra (y1.fwd y0 y1);
				wait raa;
				close ra
			}
		 |#Empty: wait a; 
			par { drop (q) ||
			send ra (u.#Empty u; close u);
			send ra (y. #Empty y; close y); 
			close ra
			}
		}
	}
};;

proc rec len(c:~LAsset,n:Nat)
{
	case c of {
	|#Empty: wait c; zero(n)
	|#One  :  cut {
				len(c,o)
				|o:~Nat|
				succ(o,n)
				}
	}
};;

/*

#One c;A'(c) |c| len(c,n) == A'(c) |c| cut { len(c,o) |o:~Nat| #S n; fwd o n }
						== #S n; (A'(c) |c| len(c,n))
*/


proc rec add(a:~Nat,b:~Nat,n:Nat)
{
	case b of {
		|#Z: wait b; fwd a n
		|#S: succ(add(a,b),n)
	}
};;


/*

proc rec debit (	q: ~Nat, a: ~LAsset, 
		     	ra: exists x: LAsset .exists y: LAsset.len(x)+len(y)=len(a)) {
	// A(a:~ LAsset)
	case q of {
	|#Z : 	sendv ra (x.fwd x a); // X(x) = fwd x a |a| A(a) 
= A(x)
		 	sendv ra (y.#Z y; close y);  // Y(y) = #Z y; close y
			wait q;
			assert ra len(x. fwd x a) + len(z.#Z z; close z) == len(a)
	|#S  : case a of {
		 |#S: cut {
				debit(q0,a,raa)
				|raa:forall x:~LNat; forall y ~LNat.len(x)+len(y)=len(a)|
				recvv raa(x0); 
				recvv raa(y0);
				coassert raa; // len(x0) + len(y0) = len(a) // check types compatible (or x0,y0 in \Sigma)
				sendv ra(x1.#S x1; fwd x0 x1); 
				sendv ra(y1.fwd y0 y1);
				assert ra len(x1.#S x1;fwd x1 x0) + len(y1.fwd y1 y0) == len(a)
					// "a" disapeared above in debit(q0,q,raa) !!
				    // need to refer to value of a at the time of call 
			}
		 |#Z: 
			// a:~#Z;close  X = a.#Z a; close a ??
			wait a; 
			discard q;
			sendv ra(x1.#Z x1; close x1);
			sendv ra(y1.#Z y1; close y1); // a:Void here!
			assert ra len(x1.#Z x1; close x1) + len(y1.#Z y1; close y1) == len(a) [ len(a.one(a)) ] !!
			// !! "a" before case and wait (a:~LNat) !
		}
	}
};;


/*

proc rec debit (	q:~Nat, a:~ LAsset, // forall A:~LAsset.
					ra:exists X: LAsset exists Y: LAsset.len(X)+len(Y)=len(A))
				   	ra: exists X:LAsset. exists Y.LAsset. 
					X(x)|x|len(x,l1) |l1| (Y(y)|y|len(Y,l2) |l2| add(l1,l2,r)
					=r= (A(x)|x|len(x,r))

				{
	// A(a:~Nat)
	case q of {
	|#Z : 	sendv ra (x.fwd x a); 		// X(x) = fwd x a |a| A(a) = A(x)
		 	sendv ra (y.#Z y; close y);  // Y(y) = #Z y; close y
			wait q;
			assert ra len(x. fwd x a) + len(z.#Z z; close z) == len(a)
			/*
			assert ra len(x. fwd x a) + len(z.#Z z; close z) =r= len(a)

			len(x,lx) |lx| len(z,lz) |lz| add(lx,lz,r) =r= len(a,r)   


			(A(x) |x| len(x,lx)) |lx| (Y(y) |y| len(y,ly) |ly| add(lx,ly,r) =r= (A(a) |a| len(a,r) )
 
			(A(x) |x| len(x,lx)) |lx| ( #Z y; close y |y| len(y,ly) |ly| add(lx,ly,r) == (A(a) |a| len(a,r) ) 
			(A(x) |x| len(x,lx)) |lx| (#Z ly; close ly |ly| add(lx,ly,r) == (A(a) |a| len(a,r) ) 
			(A(x) |x| len(x,lx)) |lx| fwd lx r == (A(a) |a| len(a,r) ) 
			(A(x) |x| len(x,r)) == (A(a) |a| len(a,r) ) 
			QED

			*/
		
	|#S  : case a of {
		 |#One: cut {

				// A(a) = #One a; A'(a)
				// A'(a)  

				debit(q0,a,raa)

				|raa:forall X0:~LNat; forall Y0 ~LNat.len(X0)+len(Y0)=len(A')|

				recvv raa(x0); // X0(x0) = 
				recvv raa(y0); // X0(y0) = 

				coassert raa; // len(x0) + len(y0) = len(a) // A'(a) in \Sigma (and in the cut)

				sendv ra(x1.#One x1; fwd x1 x0); 	// X1(x1) = #One x1; fwd x1 x0 |x0| X0(x0)
				sendv ra(y1.fwd y1 y0); 			// Y1(y1) = fwd y1 y0 |y0| Y0(x0)

				assert ra len(x1.#One x1;fwd x1 x0) + len(y1.fwd y1 y0) == len(a) // A(a) here!!
			/*
				assert ra len(x1.#One x1;fwd x1 x0) + len(y1.fwd y1 y0) == len(a)
 			
				(X1(x1) |x1| len(x1,r1)) |r1| (Y1(y1) |y1| len(y1,l1) |l1| add(r1,l1,r) == (A(a)|a|len(a,r))
				X0(x0) |x0| #One x1;fwd x1 x0 |x1| len(x1,r1))
				|r1| Y0(y0) |y0| fwd y1 y0 |y1| len(y1,l1)
				|l1| add(r1,l1,r) == A(a) |a| len(a,r)			QED

				#One x1; (X0(x0) |x0| fwd x1 x0) |x1| len(x1,r1))
				|r1| Y0(y0) |y0| fwd y1 y0 |y1| len(y1,l1)
				|l1| add(r1,l1,r) == A(a) |a| len(a,r)			QED


				#One x1; X0(x1) |x1| len(x1,r1))
				|r1| Y0(y1) |y1| len(y1,l1)
				|l1| add(r1,l1,r) == A(a) |a| len(a,r)			QED

				X0(x1) |x1| #S r1; len(x1,r1)
				|r1| Y0(y1) |y1| len(y1,l1)
				|l1| add(r1,l1,r) == A(a) |a| len(a,r)			QED

				X0(x1) |x1| len(x1,r1)
				|r1| Y0(y1) |y1| len(y1,l1)
				|l1| #S r; add(r1,l1,r) == A(a) |a| len(a,r)			QED


				#S r; (X0(x1) |x1| len(x1,r1)
				|r1| Y0(y1) |y1| len(y1,l1)
				|l1| add(r1,l1,r)) == A(a) |a| len(a,r)			

										QED ==> use len(x0) + len(y0) = len(a) // A'(a) 

				#S r; (A'(a) |a| len(a,r) == A(a) |a| len(a,r)			QED

	
				A(a) = #One a;A'(a)

				#S r; (A'(a) |a| len(a,r) == #One a;A'(a) |a| len(a,r)			QED

				#S r; (A'(a) |a| len(a,r) == #S r;(A'(a) |a| len(a,r))		QED
			*/

			}
		 |#Empty: 
				// A(a) = #Empty a; A'(a)
				// A'(a)  
			wait a; 
				// A'(a) = close a
			discard d;
			sendv ra(x1.#Empty y1; close x1);  X1(x1) = #Empty x1; close x1
			sendv ra(y1.#Empty y1; close y1); Y1(y1) = #Empty y1; close y1
			assert ra len(x1.#Empty x1;close x1) + len(y1.#Empty y1;close y1) == len(a) 

			/*
	assert ra len(x1.#Empty x1;close x1) + len(y1.#Empty y1;close y1) == len(a) 
 			
	(X1(x1) |x1| len(x1,r1)) |r1| (Y1(y1) |y1| len(y1,l1) |l1| add(r1,l1,r) == (A(a)|a|len(a,r))

	(#Empty x1; close x1|x1| len(x1,r1)) |r1| (#Empty y1; close y1 |y1| len(y1,l1) |l1| add(r1,l1,r) == (A(a)|a|len(a,r))

	#Z r1; close r1 |r1| Z l1; close l1 |l1| add(r1,l1,r) == (A(a)|a|len(a,r))

	Z r; close r == (#Empty a; A'(a) |a|len(a,r))

	Z r; close r == (#Empty a; close a |a|len(a,r)) == Z r; close r 

			*/

		}
	}
};;

/*

Example with dec (x) 

proc pos(x:~Nat, b:Bool)
	{
	case x of {
	|#S : { true(b)  || discard x }
	|#Z : { false(b) || wait x; () }
	}
};;

type Pos {
	sendv X:Nat; (b.pos(X,b) == true(b))
};;

proc dec(x:~Pos,n:Nat) {
	recvv x (v); // V(v:~Nat) 
	recvv x (p);
	check p (V(v) |v| pos(v,b) =b= true(b))
	case v of {
	| #S : // V(v) = #S v; V'(v)
			fwd v n
	| #Z : // V(v) = #Z v; V'(v)
			wait v;
			// V'(v) = close v
			// assert (false(b) =b= true(b))
			never b			  
	}
};;

*/

/*

Example with dec (x) 

proc pos(x:~Nat) returns (b:Bool)
	{
	case x of {
	|#S : { true(b)  || discard x }
	|#Z : { false(b) || wait x; () }
	}
};;

type Pos {
	sendv X:Nat; (pos(X) == true())
};;

proc dec(x:~Pos) returns (n:Nat) {
	recvv x (v); // V(v:~Nat) 
	recvv x (p);
	check p (pos(V) == true())
	case v of {
	| #S : // V(v) = #S v; V'(v)
			fwd v n
	| #Z : // V(v) = #Z v; V'(v)
			wait v;
			// V'(v) = close v
			// assert (false() == true())
			never b			  
	}
};;


proc tag(n:~Nat; tn:sendv X:Nat. sendv B:bool. pos(X) == B & N(n) == X) {
	{
	// N(n:~Nat)
	// T(tn:...)
	case n of {
	|#S : {  // N(n) = #S n;N'(n)
			  sendv tn (z.#S z.fwd z n); 
				// X(z) = #S z; N'(z) = N(z)
				// T(tn) = send tn (z.X(z)); T'(tn) ... etc
			  sendv tn (b.true(b));		// B(b) = true(b)
			  assert tn pos(X,b) == true(b)
			  assert tn pos(X) == B
	}
	|#Z : { // N(n) = #Z n;N'(n)
			  wait n; 
			 // N'(n) = close n
			  sendv tn (z.#Z z.close z); // X(z) = #Z z; close z == N(z)
			  sendv tn (b.false(b));		// B(b) = false(b)
			  assert tn pos(X,b) == false(b)}
			  // assert tn pos(X) == B }
	}
};;

*/

/*

proc rec split (	n:~Nat, a:~LAsset,
					s:sendv X: sendv Y: LAsset. len(X) + len(Y) len(a)
{
	case n of {
	|#Z : 	sendv s (a);
		 	sendv s (empty());
			wait n;
			assert s len(a) + len(empty()) len(a)
			}
	|#S  : case a of {
		 	|#One: cut {
				split(n,a,sn)
				|sn|
				recvv sn(x0);
				recvv sn(y0);  
				check sn len(x0) + len(y0) len(a) 
				sendv s(addone(x0));
				sendv s(y0); 
				assert s eq len(addone(x0)) + len(y0) len(a)
			} 
		   |#Empty: 
				wait a; 
				discard n;
				sendv s(empty());
				sendv s(empty()); 
				assert s len(empty()) + len(empty()) len(a) 
		}
	}
};;

*/
